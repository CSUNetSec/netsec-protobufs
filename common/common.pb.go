// Code generated by protoc-gen-go.
// source: github.com/CSUNetSec/netsec-protobufs/common/common.proto
// DO NOT EDIT!

/*
Package common is a generated protocol buffer package.

It is generated from these files:
	github.com/CSUNetSec/netsec-protobufs/common/common.proto

It has these top-level messages:
	IPAddressWrapper
	PrefixWrapper
	CaptureSpec
*/
package common

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// Capture specification
//
type CaptureSpec_Type int32

const (
	CaptureSpec_FLOW     CaptureSpec_Type = 0
	CaptureSpec_BGP_MRT  CaptureSpec_Type = 1
	CaptureSpec_BGP_LIVE CaptureSpec_Type = 2
)

var CaptureSpec_Type_name = map[int32]string{
	0: "FLOW",
	1: "BGP_MRT",
	2: "BGP_LIVE",
}
var CaptureSpec_Type_value = map[string]int32{
	"FLOW":     0,
	"BGP_MRT":  1,
	"BGP_LIVE": 2,
}

func (x CaptureSpec_Type) String() string {
	return proto.EnumName(CaptureSpec_Type_name, int32(x))
}
func (CaptureSpec_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type IPAddressWrapper struct {
	// must be at least one or the other
	Ipv4 []byte `protobuf:"bytes,1,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	Ipv6 []byte `protobuf:"bytes,2,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
}

func (m *IPAddressWrapper) Reset()                    { *m = IPAddressWrapper{} }
func (m *IPAddressWrapper) String() string            { return proto.CompactTextString(m) }
func (*IPAddressWrapper) ProtoMessage()               {}
func (*IPAddressWrapper) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *IPAddressWrapper) GetIpv4() []byte {
	if m != nil {
		return m.Ipv4
	}
	return nil
}

func (m *IPAddressWrapper) GetIpv6() []byte {
	if m != nil {
		return m.Ipv6
	}
	return nil
}

type PrefixWrapper struct {
	// both are really required
	Prefix *IPAddressWrapper `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	Mask   uint32            `protobuf:"varint,2,opt,name=mask" json:"mask,omitempty"`
}

func (m *PrefixWrapper) Reset()                    { *m = PrefixWrapper{} }
func (m *PrefixWrapper) String() string            { return proto.CompactTextString(m) }
func (*PrefixWrapper) ProtoMessage()               {}
func (*PrefixWrapper) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PrefixWrapper) GetPrefix() *IPAddressWrapper {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *PrefixWrapper) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

// We try to keep as much state about the file that we convert as we
// can, so we have some idea of where this data came from and who
// handled it
type CaptureSpec struct {
	// each flow needs a proper id. Such an id is local to the file
	// in which records refer to it. The capture_spec_id is *not* global.
	// Global significance is actually the remainder of the fields.
	CaptureSpecId int32 `protobuf:"varint,1,opt,name=capture_spec_id,json=captureSpecId" json:"capture_spec_id,omitempty"`
	// Some applications, e.g., BGP may be logging verbose debugging
	// ID's instead of doing a lookup on the capture_spec id above.
	// the caputre spec and debug_id should have a 1-1 mapping between
	// them, but the verbose debug id is self-contained.
	VerboseDebugId    []byte           `protobuf:"bytes,12,opt,name=verbose_debug_id,json=verboseDebugId,proto3" json:"verbose_debug_id,omitempty"`
	Type              CaptureSpec_Type `protobuf:"varint,14,opt,name=type,enum=common.CaptureSpec_Type" json:"type,omitempty"`
	TcpdumpExpression string           `protobuf:"bytes,2,opt,name=tcpdump_expression,json=tcpdumpExpression" json:"tcpdump_expression,omitempty"`
	// What is the location of the capture in string format
	// AT&T West LAX POP 1123231
	CaptureLocation string `protobuf:"bytes,3,opt,name=capture_location,json=captureLocation" json:"capture_location,omitempty"`
	// What is the location in terms of IP
	CaptureLocationIp *IPAddressWrapper `protobuf:"bytes,4,opt,name=capture_location_ip,json=captureLocationIp" json:"capture_location_ip,omitempty"`
	// if the capture node has a dns name, this is it
	// FQDN e.g., intercept.ny.nofutz.com
	CaptureLocationDns string `protobuf:"bytes,5,opt,name=capture_location_dns,json=captureLocationDns" json:"capture_location_dns,omitempty"`
	// if there are multiple capture devices in a location
	// which device is this spec.
	// e.g., capturehost01.intercept.ny.nofutz.com
	CaptureNodeSpec string `protobuf:"bytes,6,opt,name=capture_node_spec,json=captureNodeSpec" json:"capture_node_spec,omitempty"`
	// The interface on which the data was sniffed
	// ETH10
	CaptureNodeInterface []string `protobuf:"bytes,7,rep,name=capture_node_interface,json=captureNodeInterface" json:"capture_node_interface,omitempty"`
	// For BGP we may only be capturing a link between this
	// capture location IP and the ptp_peer.
	PtpPeer *IPAddressWrapper `protobuf:"bytes,13,opt,name=ptp_peer,json=ptpPeer" json:"ptp_peer,omitempty"`
	// Capture retrieval specification. The capture was originally
	// stored somewhere in some file. The original file is identified
	// below. This is important for provenance, e.g., we might have
	// to filter out data that was stored on a compromised host.
	// And if we ever have a bug, this should allow us to reconstruct our
	// state from the source data.
	StorageHost []string `protobuf:"bytes,8,rep,name=storage_host,json=storageHost" json:"storage_host,omitempty"`
	PathToFiles []string `protobuf:"bytes,9,rep,name=path_to_files,json=pathToFiles" json:"path_to_files,omitempty"`
	// A pattern that allows us to identify the sequence of files. The
	// expression is expected to be a PCRE expression.
	//    http://www.pcre.org/current/doc/html/
	//
	// For example, "capture_(%d+)" says that the files are named
	// capture with the sequence number appended after the _
	FilePattern []string `protobuf:"bytes,10,rep,name=file_pattern,json=filePattern" json:"file_pattern,omitempty"`
	// Username of the file owner
	Username string `protobuf:"bytes,11,opt,name=username" json:"username,omitempty"`
}

func (m *CaptureSpec) Reset()                    { *m = CaptureSpec{} }
func (m *CaptureSpec) String() string            { return proto.CompactTextString(m) }
func (*CaptureSpec) ProtoMessage()               {}
func (*CaptureSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CaptureSpec) GetCaptureSpecId() int32 {
	if m != nil {
		return m.CaptureSpecId
	}
	return 0
}

func (m *CaptureSpec) GetVerboseDebugId() []byte {
	if m != nil {
		return m.VerboseDebugId
	}
	return nil
}

func (m *CaptureSpec) GetType() CaptureSpec_Type {
	if m != nil {
		return m.Type
	}
	return CaptureSpec_FLOW
}

func (m *CaptureSpec) GetTcpdumpExpression() string {
	if m != nil {
		return m.TcpdumpExpression
	}
	return ""
}

func (m *CaptureSpec) GetCaptureLocation() string {
	if m != nil {
		return m.CaptureLocation
	}
	return ""
}

func (m *CaptureSpec) GetCaptureLocationIp() *IPAddressWrapper {
	if m != nil {
		return m.CaptureLocationIp
	}
	return nil
}

func (m *CaptureSpec) GetCaptureLocationDns() string {
	if m != nil {
		return m.CaptureLocationDns
	}
	return ""
}

func (m *CaptureSpec) GetCaptureNodeSpec() string {
	if m != nil {
		return m.CaptureNodeSpec
	}
	return ""
}

func (m *CaptureSpec) GetCaptureNodeInterface() []string {
	if m != nil {
		return m.CaptureNodeInterface
	}
	return nil
}

func (m *CaptureSpec) GetPtpPeer() *IPAddressWrapper {
	if m != nil {
		return m.PtpPeer
	}
	return nil
}

func (m *CaptureSpec) GetStorageHost() []string {
	if m != nil {
		return m.StorageHost
	}
	return nil
}

func (m *CaptureSpec) GetPathToFiles() []string {
	if m != nil {
		return m.PathToFiles
	}
	return nil
}

func (m *CaptureSpec) GetFilePattern() []string {
	if m != nil {
		return m.FilePattern
	}
	return nil
}

func (m *CaptureSpec) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func init() {
	proto.RegisterType((*IPAddressWrapper)(nil), "common.IPAddressWrapper")
	proto.RegisterType((*PrefixWrapper)(nil), "common.PrefixWrapper")
	proto.RegisterType((*CaptureSpec)(nil), "common.CaptureSpec")
	proto.RegisterEnum("common.CaptureSpec_Type", CaptureSpec_Type_name, CaptureSpec_Type_value)
}

func init() {
	proto.RegisterFile("github.com/CSUNetSec/netsec-protobufs/common/common.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 505 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x93, 0x4b, 0x4f, 0xdb, 0x40,
	0x10, 0xc7, 0x0b, 0xe4, 0xc5, 0xe4, 0x51, 0xb3, 0x45, 0xd5, 0xaa, 0x27, 0x9a, 0x43, 0x45, 0x1f,
	0x24, 0x55, 0x41, 0x48, 0xed, 0xad, 0xe5, 0x51, 0x22, 0xa5, 0x34, 0x72, 0x42, 0x39, 0xae, 0xfc,
	0x98, 0x24, 0x56, 0xb1, 0x77, 0xb5, 0xbb, 0x46, 0xf4, 0x43, 0xf5, 0x3b, 0x76, 0x77, 0x6d, 0x07,
	0x48, 0x0f, 0x9c, 0xbc, 0xf3, 0x9b, 0xff, 0xfc, 0x67, 0x66, 0x6d, 0xc3, 0xe7, 0x45, 0xa2, 0x97,
	0x79, 0x38, 0x88, 0x78, 0x3a, 0x3c, 0x99, 0x5e, 0x5d, 0xa2, 0x9e, 0x62, 0x34, 0xcc, 0x50, 0x2b,
	0x8c, 0x0e, 0x84, 0xe4, 0x9a, 0x87, 0xf9, 0x5c, 0x0d, 0x4d, 0x3a, 0xe5, 0x59, 0xf9, 0x18, 0x38,
	0x4e, 0x1a, 0x45, 0xd4, 0xff, 0x02, 0xde, 0x68, 0xf2, 0x35, 0x8e, 0x25, 0x2a, 0x75, 0x2d, 0x03,
	0x21, 0x50, 0x12, 0x02, 0xb5, 0x44, 0xdc, 0x1e, 0xd1, 0x8d, 0xbd, 0x8d, 0xfd, 0x8e, 0xef, 0xce,
	0x25, 0x3b, 0xa6, 0x9b, 0x2b, 0x76, 0xdc, 0xbf, 0x82, 0xee, 0x44, 0xe2, 0x3c, 0xb9, 0xab, 0x0a,
	0x3f, 0x42, 0x43, 0x38, 0xe0, 0x4a, 0xdb, 0x9f, 0xe8, 0xa0, 0xec, 0xb9, 0xde, 0xc2, 0x2f, 0x75,
	0xd6, 0x36, 0x0d, 0xd4, 0x6f, 0x67, 0xdb, 0xf5, 0xdd, 0xb9, 0xff, 0xb7, 0x0e, 0xed, 0x93, 0x40,
	0xe8, 0x5c, 0xe2, 0x54, 0x60, 0x44, 0xde, 0xc0, 0xf3, 0xa8, 0x08, 0x99, 0x32, 0x31, 0x4b, 0x62,
	0x67, 0x5f, 0xf7, 0xbb, 0xd1, 0xbd, 0x6a, 0x14, 0x93, 0x7d, 0xf0, 0x6e, 0x51, 0x86, 0x5c, 0x21,
	0x8b, 0x31, 0xcc, 0x17, 0x56, 0xd8, 0x71, 0xe3, 0xf6, 0x4a, 0x7e, 0x6a, 0xb1, 0x51, 0x7e, 0x80,
	0x9a, 0xfe, 0x23, 0x90, 0xf6, 0x4c, 0xb6, 0x77, 0x3f, 0xe5, 0x83, 0xa6, 0x83, 0x99, 0xc9, 0xfb,
	0x4e, 0x45, 0x0e, 0x80, 0xe8, 0x48, 0xc4, 0x79, 0x2a, 0x18, 0xde, 0x09, 0xbb, 0x45, 0xc2, 0x33,
	0x37, 0xf1, 0xb6, 0xbf, 0x53, 0x66, 0xce, 0x56, 0x09, 0xf2, 0x16, 0xbc, 0x6a, 0xdc, 0x1b, 0x1e,
	0x05, 0xda, 0x8a, 0xb7, 0x9c, 0xb8, 0x5a, 0x63, 0x5c, 0x62, 0x72, 0x01, 0x2f, 0xd6, 0xa5, 0x2c,
	0x11, 0xb4, 0xf6, 0xc4, 0xe5, 0xed, 0xac, 0xf9, 0x8c, 0x84, 0xb9, 0xf9, 0xdd, 0xff, 0x9c, 0xe2,
	0x4c, 0xd1, 0xba, 0x6b, 0x4c, 0xd6, 0x0a, 0x4e, 0x33, 0x45, 0xde, 0x41, 0x65, 0xc3, 0x32, 0x1e,
	0x17, 0x57, 0x4b, 0x1b, 0x8f, 0xe6, 0xbc, 0x34, 0xdc, 0xbd, 0x81, 0x23, 0x78, 0xf9, 0x48, 0x9b,
	0x64, 0x1a, 0xe5, 0x3c, 0x88, 0x90, 0x36, 0xf7, 0xb6, 0x4c, 0xc1, 0xee, 0x83, 0x82, 0x51, 0x95,
	0x23, 0x87, 0xd0, 0x12, 0x5a, 0x30, 0x81, 0x28, 0x69, 0xf7, 0x89, 0x95, 0x9a, 0x46, 0x39, 0x31,
	0x42, 0xf2, 0x1a, 0x3a, 0x4a, 0x73, 0x19, 0x2c, 0x90, 0x2d, 0xb9, 0xd2, 0xb4, 0xe5, 0x1a, 0xb4,
	0x4b, 0x76, 0x61, 0x10, 0xe9, 0x43, 0x57, 0x04, 0x7a, 0xc9, 0x34, 0x67, 0xf3, 0xe4, 0x06, 0x15,
	0xdd, 0x2e, 0x34, 0x16, 0xce, 0xf8, 0xb9, 0x45, 0xd6, 0xc6, 0xe6, 0x98, 0x61, 0x66, 0x9c, 0x8c,
	0x42, 0x21, 0xb1, 0x6c, 0x52, 0x20, 0xf2, 0x0a, 0x5a, 0xb9, 0x32, 0x87, 0x20, 0x45, 0xda, 0x76,
	0x7b, 0xaf, 0xe2, 0xfe, 0x7b, 0xa8, 0xd9, 0x0f, 0x80, 0xb4, 0xa0, 0x76, 0x3e, 0xfe, 0x79, 0xed,
	0x3d, 0x23, 0x6d, 0x68, 0x7e, 0xfb, 0x3e, 0x61, 0x3f, 0xfc, 0x99, 0xb7, 0x41, 0x3a, 0xd0, 0xb2,
	0xc1, 0x78, 0xf4, 0xeb, 0xcc, 0xdb, 0x0c, 0x1b, 0xee, 0x8f, 0x3a, 0xfc, 0x17, 0x00, 0x00, 0xff,
	0xff, 0xe4, 0xc4, 0x4c, 0xb9, 0x8e, 0x03, 0x00, 0x00,
}
