// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/CSUNetSec/netsec-protobufs/common/common.proto

package common

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//
// Capture specification
//
type CaptureSpec_Type int32

const (
	CaptureSpec_FLOW     CaptureSpec_Type = 0
	CaptureSpec_BGP_MRT  CaptureSpec_Type = 1
	CaptureSpec_BGP_LIVE CaptureSpec_Type = 2
)

var CaptureSpec_Type_name = map[int32]string{
	0: "FLOW",
	1: "BGP_MRT",
	2: "BGP_LIVE",
}

var CaptureSpec_Type_value = map[string]int32{
	"FLOW":     0,
	"BGP_MRT":  1,
	"BGP_LIVE": 2,
}

func (x CaptureSpec_Type) String() string {
	return proto.EnumName(CaptureSpec_Type_name, int32(x))
}

func (CaptureSpec_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_20cff418fddf53fb, []int{2, 0}
}

type IPAddressWrapper struct {
	// must be at least one or the other
	Ipv4                 []byte   `protobuf:"bytes,1,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	Ipv6                 []byte   `protobuf:"bytes,2,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPAddressWrapper) Reset()         { *m = IPAddressWrapper{} }
func (m *IPAddressWrapper) String() string { return proto.CompactTextString(m) }
func (*IPAddressWrapper) ProtoMessage()    {}
func (*IPAddressWrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_20cff418fddf53fb, []int{0}
}

func (m *IPAddressWrapper) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPAddressWrapper.Unmarshal(m, b)
}
func (m *IPAddressWrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPAddressWrapper.Marshal(b, m, deterministic)
}
func (m *IPAddressWrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPAddressWrapper.Merge(m, src)
}
func (m *IPAddressWrapper) XXX_Size() int {
	return xxx_messageInfo_IPAddressWrapper.Size(m)
}
func (m *IPAddressWrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_IPAddressWrapper.DiscardUnknown(m)
}

var xxx_messageInfo_IPAddressWrapper proto.InternalMessageInfo

func (m *IPAddressWrapper) GetIpv4() []byte {
	if m != nil {
		return m.Ipv4
	}
	return nil
}

func (m *IPAddressWrapper) GetIpv6() []byte {
	if m != nil {
		return m.Ipv6
	}
	return nil
}

type PrefixWrapper struct {
	// both are really required
	Prefix               *IPAddressWrapper `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Mask                 uint32            `protobuf:"varint,2,opt,name=mask,proto3" json:"mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PrefixWrapper) Reset()         { *m = PrefixWrapper{} }
func (m *PrefixWrapper) String() string { return proto.CompactTextString(m) }
func (*PrefixWrapper) ProtoMessage()    {}
func (*PrefixWrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_20cff418fddf53fb, []int{1}
}

func (m *PrefixWrapper) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PrefixWrapper.Unmarshal(m, b)
}
func (m *PrefixWrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PrefixWrapper.Marshal(b, m, deterministic)
}
func (m *PrefixWrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefixWrapper.Merge(m, src)
}
func (m *PrefixWrapper) XXX_Size() int {
	return xxx_messageInfo_PrefixWrapper.Size(m)
}
func (m *PrefixWrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefixWrapper.DiscardUnknown(m)
}

var xxx_messageInfo_PrefixWrapper proto.InternalMessageInfo

func (m *PrefixWrapper) GetPrefix() *IPAddressWrapper {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *PrefixWrapper) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

// We try to keep as much state about the file that we convert as we
// can, so we have some idea of where this data came from and who
// handled it
type CaptureSpec struct {
	// each flow needs a proper id. Such an id is local to the file
	// in which records refer to it. The capture_spec_id is *not* global.
	// Global significance is actually the remainder of the fields.
	CaptureSpecId int32 `protobuf:"varint,1,opt,name=capture_spec_id,json=captureSpecId,proto3" json:"capture_spec_id,omitempty"`
	// Some applications, e.g., BGP may be logging verbose debugging
	// ID's instead of doing a lookup on the capture_spec id above.
	// the caputre spec and debug_id should have a 1-1 mapping between
	// them, but the verbose debug id is self-contained.
	VerboseDebugId    []byte           `protobuf:"bytes,12,opt,name=verbose_debug_id,json=verboseDebugId,proto3" json:"verbose_debug_id,omitempty"`
	Type              CaptureSpec_Type `protobuf:"varint,14,opt,name=type,proto3,enum=common.CaptureSpec_Type" json:"type,omitempty"`
	TcpdumpExpression string           `protobuf:"bytes,2,opt,name=tcpdump_expression,json=tcpdumpExpression,proto3" json:"tcpdump_expression,omitempty"`
	// What is the location of the capture in string format
	// AT&T West LAX POP 1123231
	CaptureLocation string `protobuf:"bytes,3,opt,name=capture_location,json=captureLocation,proto3" json:"capture_location,omitempty"`
	// What is the location in terms of IP
	CaptureLocationIp *IPAddressWrapper `protobuf:"bytes,4,opt,name=capture_location_ip,json=captureLocationIp,proto3" json:"capture_location_ip,omitempty"`
	// if the capture node has a dns name, this is it
	// FQDN e.g., intercept.ny.nofutz.com
	CaptureLocationDns string `protobuf:"bytes,5,opt,name=capture_location_dns,json=captureLocationDns,proto3" json:"capture_location_dns,omitempty"`
	// if there are multiple capture devices in a location
	// which device is this spec.
	// e.g., capturehost01.intercept.ny.nofutz.com
	CaptureNodeSpec string `protobuf:"bytes,6,opt,name=capture_node_spec,json=captureNodeSpec,proto3" json:"capture_node_spec,omitempty"`
	// The interface on which the data was sniffed
	// ETH10
	CaptureNodeInterface []string `protobuf:"bytes,7,rep,name=capture_node_interface,json=captureNodeInterface,proto3" json:"capture_node_interface,omitempty"`
	// For BGP we may only be capturing a link between this
	// capture location IP and the ptp_peer.
	PtpPeer *IPAddressWrapper `protobuf:"bytes,13,opt,name=ptp_peer,json=ptpPeer,proto3" json:"ptp_peer,omitempty"`
	// Capture retrieval specification. The capture was originally
	// stored somewhere in some file. The original file is identified
	// below. This is important for provenance, e.g., we might have
	// to filter out data that was stored on a compromised host.
	// And if we ever have a bug, this should allow us to reconstruct our
	// state from the source data.
	StorageHost []string `protobuf:"bytes,8,rep,name=storage_host,json=storageHost,proto3" json:"storage_host,omitempty"`
	PathToFiles []string `protobuf:"bytes,9,rep,name=path_to_files,json=pathToFiles,proto3" json:"path_to_files,omitempty"`
	// A pattern that allows us to identify the sequence of files. The
	// expression is expected to be a PCRE expression.
	//    http://www.pcre.org/current/doc/html/
	//
	// For example, "capture_(%d+)" says that the files are named
	// capture with the sequence number appended after the _
	FilePattern []string `protobuf:"bytes,10,rep,name=file_pattern,json=filePattern,proto3" json:"file_pattern,omitempty"`
	// Username of the file owner
	Username             string   `protobuf:"bytes,11,opt,name=username,proto3" json:"username,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CaptureSpec) Reset()         { *m = CaptureSpec{} }
func (m *CaptureSpec) String() string { return proto.CompactTextString(m) }
func (*CaptureSpec) ProtoMessage()    {}
func (*CaptureSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_20cff418fddf53fb, []int{2}
}

func (m *CaptureSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CaptureSpec.Unmarshal(m, b)
}
func (m *CaptureSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CaptureSpec.Marshal(b, m, deterministic)
}
func (m *CaptureSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CaptureSpec.Merge(m, src)
}
func (m *CaptureSpec) XXX_Size() int {
	return xxx_messageInfo_CaptureSpec.Size(m)
}
func (m *CaptureSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CaptureSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CaptureSpec proto.InternalMessageInfo

func (m *CaptureSpec) GetCaptureSpecId() int32 {
	if m != nil {
		return m.CaptureSpecId
	}
	return 0
}

func (m *CaptureSpec) GetVerboseDebugId() []byte {
	if m != nil {
		return m.VerboseDebugId
	}
	return nil
}

func (m *CaptureSpec) GetType() CaptureSpec_Type {
	if m != nil {
		return m.Type
	}
	return CaptureSpec_FLOW
}

func (m *CaptureSpec) GetTcpdumpExpression() string {
	if m != nil {
		return m.TcpdumpExpression
	}
	return ""
}

func (m *CaptureSpec) GetCaptureLocation() string {
	if m != nil {
		return m.CaptureLocation
	}
	return ""
}

func (m *CaptureSpec) GetCaptureLocationIp() *IPAddressWrapper {
	if m != nil {
		return m.CaptureLocationIp
	}
	return nil
}

func (m *CaptureSpec) GetCaptureLocationDns() string {
	if m != nil {
		return m.CaptureLocationDns
	}
	return ""
}

func (m *CaptureSpec) GetCaptureNodeSpec() string {
	if m != nil {
		return m.CaptureNodeSpec
	}
	return ""
}

func (m *CaptureSpec) GetCaptureNodeInterface() []string {
	if m != nil {
		return m.CaptureNodeInterface
	}
	return nil
}

func (m *CaptureSpec) GetPtpPeer() *IPAddressWrapper {
	if m != nil {
		return m.PtpPeer
	}
	return nil
}

func (m *CaptureSpec) GetStorageHost() []string {
	if m != nil {
		return m.StorageHost
	}
	return nil
}

func (m *CaptureSpec) GetPathToFiles() []string {
	if m != nil {
		return m.PathToFiles
	}
	return nil
}

func (m *CaptureSpec) GetFilePattern() []string {
	if m != nil {
		return m.FilePattern
	}
	return nil
}

func (m *CaptureSpec) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func init() {
	proto.RegisterEnum("common.CaptureSpec_Type", CaptureSpec_Type_name, CaptureSpec_Type_value)
	proto.RegisterType((*IPAddressWrapper)(nil), "common.IPAddressWrapper")
	proto.RegisterType((*PrefixWrapper)(nil), "common.PrefixWrapper")
	proto.RegisterType((*CaptureSpec)(nil), "common.CaptureSpec")
}

func init() {
	proto.RegisterFile("github.com/CSUNetSec/netsec-protobufs/common/common.proto", fileDescriptor_20cff418fddf53fb)
}

var fileDescriptor_20cff418fddf53fb = []byte{
	// 510 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0x4b, 0x4f, 0xdb, 0x40,
	0x10, 0xc7, 0x1b, 0x08, 0x21, 0x4c, 0x1e, 0x35, 0x5b, 0x54, 0xad, 0x7a, 0x4a, 0x73, 0xa8, 0xd2,
	0x07, 0x09, 0x2a, 0x08, 0xa9, 0xbd, 0xb5, 0x3c, 0x8a, 0xa5, 0x94, 0x46, 0x4e, 0x28, 0xc7, 0x95,
	0x63, 0x4f, 0x12, 0xab, 0xd8, 0x3b, 0xda, 0x5d, 0x23, 0xf8, 0x50, 0xfd, 0x8e, 0xd5, 0xae, 0x9d,
	0x00, 0xe9, 0x81, 0x93, 0x77, 0x7e, 0xf3, 0x9f, 0xff, 0xcc, 0xac, 0x6d, 0xf8, 0x32, 0x4f, 0xcc,
	0x22, 0x9f, 0xf6, 0x23, 0x99, 0x0e, 0x4e, 0xc6, 0x57, 0x97, 0x68, 0xc6, 0x18, 0x0d, 0x32, 0x34,
	0x1a, 0xa3, 0x7d, 0x52, 0xd2, 0xc8, 0x69, 0x3e, 0xd3, 0x83, 0x48, 0xa6, 0xa9, 0xcc, 0xca, 0x47,
	0xdf, 0x71, 0x56, 0x2b, 0xa2, 0xee, 0x57, 0xf0, 0xfc, 0xd1, 0xb7, 0x38, 0x56, 0xa8, 0xf5, 0xb5,
	0x0a, 0x89, 0x50, 0x31, 0x06, 0xd5, 0x84, 0x6e, 0x8f, 0x78, 0xa5, 0x53, 0xe9, 0x35, 0x03, 0x77,
	0x2e, 0xd9, 0x31, 0xdf, 0x58, 0xb1, 0xe3, 0xee, 0x15, 0xb4, 0x46, 0x0a, 0x67, 0xc9, 0xdd, 0xb2,
	0xf0, 0x00, 0x6a, 0xe4, 0x80, 0x2b, 0x6d, 0x7c, 0xe6, 0xfd, 0xb2, 0xe7, 0x7a, 0x8b, 0xa0, 0xd4,
	0x59, 0xdb, 0x34, 0xd4, 0x7f, 0x9c, 0x6d, 0x2b, 0x70, 0xe7, 0xee, 0xdf, 0x2d, 0x68, 0x9c, 0x84,
	0x64, 0x72, 0x85, 0x63, 0xc2, 0x88, 0xbd, 0x83, 0x97, 0x51, 0x11, 0x0a, 0x4d, 0x18, 0x89, 0x24,
	0x76, 0xf6, 0x5b, 0x41, 0x2b, 0x7a, 0x50, 0xf9, 0x31, 0xeb, 0x81, 0x77, 0x8b, 0x6a, 0x2a, 0x35,
	0x8a, 0x18, 0xa7, 0xf9, 0xdc, 0x0a, 0x9b, 0x6e, 0xdc, 0x76, 0xc9, 0x4f, 0x2d, 0xf6, 0x63, 0xf6,
	0x09, 0xaa, 0xe6, 0x9e, 0x90, 0xb7, 0x3b, 0x95, 0x5e, 0xfb, 0x61, 0xca, 0x47, 0x4d, 0xfb, 0x93,
	0x7b, 0xc2, 0xc0, 0xa9, 0xd8, 0x3e, 0x30, 0x13, 0x51, 0x9c, 0xa7, 0x24, 0xf0, 0x8e, 0xec, 0x16,
	0x89, 0xcc, 0xdc, 0xc4, 0x3b, 0xc1, 0x6e, 0x99, 0x39, 0x5b, 0x25, 0xd8, 0x7b, 0xf0, 0x96, 0xe3,
	0xde, 0xc8, 0x28, 0x34, 0x56, 0xbc, 0xe9, 0xc4, 0xcb, 0x35, 0x86, 0x25, 0x66, 0x17, 0xf0, 0x6a,
	0x5d, 0x2a, 0x12, 0xe2, 0xd5, 0x67, 0x2e, 0x6f, 0x77, 0xcd, 0xc7, 0x27, 0x76, 0x00, 0x7b, 0xff,
	0x39, 0xc5, 0x99, 0xe6, 0x5b, 0xae, 0x31, 0x5b, 0x2b, 0x38, 0xcd, 0x34, 0xfb, 0x00, 0x4b, 0x1b,
	0x91, 0xc9, 0xb8, 0xb8, 0x5a, 0x5e, 0x7b, 0x32, 0xe7, 0xa5, 0x8c, 0x8b, 0x37, 0x70, 0x04, 0xaf,
	0x9f, 0x68, 0x93, 0xcc, 0xa0, 0x9a, 0x85, 0x11, 0xf2, 0xed, 0xce, 0x66, 0x6f, 0x27, 0xd8, 0x7b,
	0x54, 0xe0, 0x2f, 0x73, 0xec, 0x10, 0xea, 0x64, 0x48, 0x10, 0xa2, 0xe2, 0xad, 0x67, 0x56, 0xda,
	0x26, 0x43, 0x23, 0x44, 0xc5, 0xde, 0x42, 0x53, 0x1b, 0xa9, 0xc2, 0x39, 0x8a, 0x85, 0xd4, 0x86,
	0xd7, 0x5d, 0x83, 0x46, 0xc9, 0x2e, 0xa4, 0x36, 0xac, 0x0b, 0x2d, 0x0a, 0xcd, 0x42, 0x18, 0x29,
	0x66, 0xc9, 0x0d, 0x6a, 0xbe, 0x53, 0x68, 0x2c, 0x9c, 0xc8, 0x73, 0x8b, 0xac, 0x8d, 0xcd, 0x09,
	0x0a, 0x8d, 0x41, 0x95, 0x71, 0x28, 0x24, 0x96, 0x8d, 0x0a, 0xc4, 0xde, 0x40, 0x3d, 0xd7, 0xa8,
	0xb2, 0x30, 0x45, 0xde, 0x70, 0x7b, 0xaf, 0xe2, 0xee, 0x47, 0xa8, 0xda, 0x0f, 0x80, 0xd5, 0xa1,
	0x7a, 0x3e, 0xfc, 0x75, 0xed, 0xbd, 0x60, 0x0d, 0xd8, 0xfe, 0xfe, 0x63, 0x24, 0x7e, 0x06, 0x13,
	0xaf, 0xc2, 0x9a, 0x50, 0xb7, 0xc1, 0xd0, 0xff, 0x7d, 0xe6, 0x6d, 0x4c, 0x6b, 0xee, 0x8f, 0x3a,
	0xfc, 0x17, 0x00, 0x00, 0xff, 0xff, 0xe4, 0xc4, 0x4c, 0xb9, 0x8e, 0x03, 0x00, 0x00,
}
