// Code generated by protoc-gen-go.
// source: github.com/CSUNetSec/netsec-protobufs/netbrane/netbrane.proto
// DO NOT EDIT!

/*
Package nofutz_FlowMinder is a generated protocol buffer package.

It is generated from these files:
	github.com/CSUNetSec/netsec-protobufs/netbrane/netbrane.proto

It has these top-level messages:
	PacketData
	IPFlow
	FlowRecord
	DNSRecord
	CaptureRecordUnion
*/
package nofutz_FlowMinder

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "github.com/CSUNetSec/netsec-protobufs/common"
import bgp "github.com/CSUNetSec/netsec-protobufs/protocol/bgp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FlowRecord_L2Proto int32

const (
	FlowRecord_L2_NONE     FlowRecord_L2Proto = 0
	FlowRecord_L2_ETHERNET FlowRecord_L2Proto = 1
)

var FlowRecord_L2Proto_name = map[int32]string{
	0: "L2_NONE",
	1: "L2_ETHERNET",
}
var FlowRecord_L2Proto_value = map[string]int32{
	"L2_NONE":     0,
	"L2_ETHERNET": 1,
}

func (x FlowRecord_L2Proto) Enum() *FlowRecord_L2Proto {
	p := new(FlowRecord_L2Proto)
	*p = x
	return p
}
func (x FlowRecord_L2Proto) String() string {
	return proto.EnumName(FlowRecord_L2Proto_name, int32(x))
}
func (x *FlowRecord_L2Proto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FlowRecord_L2Proto_value, data, "FlowRecord_L2Proto")
	if err != nil {
		return err
	}
	*x = FlowRecord_L2Proto(value)
	return nil
}
func (FlowRecord_L2Proto) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type CaptureRecordUnion_RecordType int32

const (
	CaptureRecordUnion_CAPTURE_SPEC      CaptureRecordUnion_RecordType = 1
	CaptureRecordUnion_FLOW_RECORD       CaptureRecordUnion_RecordType = 2
	CaptureRecordUnion_BGP_UPDATE_RECORD CaptureRecordUnion_RecordType = 3
	CaptureRecordUnion_DNS_RECORD        CaptureRecordUnion_RecordType = 4
)

var CaptureRecordUnion_RecordType_name = map[int32]string{
	1: "CAPTURE_SPEC",
	2: "FLOW_RECORD",
	3: "BGP_UPDATE_RECORD",
	4: "DNS_RECORD",
}
var CaptureRecordUnion_RecordType_value = map[string]int32{
	"CAPTURE_SPEC":      1,
	"FLOW_RECORD":       2,
	"BGP_UPDATE_RECORD": 3,
	"DNS_RECORD":        4,
}

func (x CaptureRecordUnion_RecordType) Enum() *CaptureRecordUnion_RecordType {
	p := new(CaptureRecordUnion_RecordType)
	*p = x
	return p
}
func (x CaptureRecordUnion_RecordType) String() string {
	return proto.EnumName(CaptureRecordUnion_RecordType_name, int32(x))
}
func (x *CaptureRecordUnion_RecordType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CaptureRecordUnion_RecordType_value, data, "CaptureRecordUnion_RecordType")
	if err != nil {
		return err
	}
	*x = CaptureRecordUnion_RecordType(value)
	return nil
}
func (CaptureRecordUnion_RecordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

// We don't always capture packet data. If we do, this is
// the format
type PacketData struct {
	NanosSinceFlowStart *uint64 `protobuf:"varint,1,opt,name=nanos_since_flow_start,json=nanosSinceFlowStart" json:"nanos_since_flow_start,omitempty"`
	PacketSize          *uint32 `protobuf:"varint,2,opt,name=packet_size,json=packetSize" json:"packet_size,omitempty"`
	// IP per packet see RFC 791
	IpId *uint32 `protobuf:"varint,3,opt,name=ip_id,json=ipId" json:"ip_id,omitempty"`
	// either more fragments after this or offset != 0
	IsFragment *bool `protobuf:"varint,4,opt,name=is_fragment,json=isFragment" json:"is_fragment,omitempty"`
	// TCP related follows RFC 793
	// This is the window advertisement
	// in bytes.
	WindowSize *int32  `protobuf:"varint,5,opt,name=window_size,json=windowSize" json:"window_size,omitempty"`
	Sequence   *uint32 `protobuf:"varint,6,opt,name=sequence" json:"sequence,omitempty"`
	Ack        *uint32 `protobuf:"varint,7,opt,name=ack" json:"ack,omitempty"`
	Syn        *bool   `protobuf:"varint,8,opt,name=syn" json:"syn,omitempty"`
	Fin        *bool   `protobuf:"varint,9,opt,name=fin" json:"fin,omitempty"`
	Reset_     *bool   `protobuf:"varint,10,opt,name=reset" json:"reset,omitempty"`
	// Do we need more understanding of options ip and otherwise
	OptionsL3        *bool  `protobuf:"varint,11,opt,name=options_l3,json=optionsL3" json:"options_l3,omitempty"`
	OptionsL4        *bool  `protobuf:"varint,12,opt,name=options_l4,json=optionsL4" json:"options_l4,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PacketData) Reset()                    { *m = PacketData{} }
func (m *PacketData) String() string            { return proto.CompactTextString(m) }
func (*PacketData) ProtoMessage()               {}
func (*PacketData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PacketData) GetNanosSinceFlowStart() uint64 {
	if m != nil && m.NanosSinceFlowStart != nil {
		return *m.NanosSinceFlowStart
	}
	return 0
}

func (m *PacketData) GetPacketSize() uint32 {
	if m != nil && m.PacketSize != nil {
		return *m.PacketSize
	}
	return 0
}

func (m *PacketData) GetIpId() uint32 {
	if m != nil && m.IpId != nil {
		return *m.IpId
	}
	return 0
}

func (m *PacketData) GetIsFragment() bool {
	if m != nil && m.IsFragment != nil {
		return *m.IsFragment
	}
	return false
}

func (m *PacketData) GetWindowSize() int32 {
	if m != nil && m.WindowSize != nil {
		return *m.WindowSize
	}
	return 0
}

func (m *PacketData) GetSequence() uint32 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

func (m *PacketData) GetAck() uint32 {
	if m != nil && m.Ack != nil {
		return *m.Ack
	}
	return 0
}

func (m *PacketData) GetSyn() bool {
	if m != nil && m.Syn != nil {
		return *m.Syn
	}
	return false
}

func (m *PacketData) GetFin() bool {
	if m != nil && m.Fin != nil {
		return *m.Fin
	}
	return false
}

func (m *PacketData) GetReset_() bool {
	if m != nil && m.Reset_ != nil {
		return *m.Reset_
	}
	return false
}

func (m *PacketData) GetOptionsL3() bool {
	if m != nil && m.OptionsL3 != nil {
		return *m.OptionsL3
	}
	return false
}

func (m *PacketData) GetOptionsL4() bool {
	if m != nil && m.OptionsL4 != nil {
		return *m.OptionsL4
	}
	return false
}

// Flow originates at address
type IPFlow struct {
	// really required
	Address *common.IPAddressWrapper `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// we may aggregate flows for an entire subnet if we
	// get too fine-grained with individual flow records.
	Mask  *common.IPAddressWrapper `protobuf:"bytes,2,opt,name=mask" json:"mask,omitempty"`
	Port  *int32                   `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
	Tos   *int32                   `protobuf:"varint,4,opt,name=tos" json:"tos,omitempty"`
	Ttl   *int32                   `protobuf:"varint,5,opt,name=ttl" json:"ttl,omitempty"`
	Bytes *int64                   `protobuf:"varint,6,opt,name=bytes" json:"bytes,omitempty"`
	// Some sniffers may be able to parse the number of acutal payload bytes
	ApplicationBytes *int64   `protobuf:"varint,7,opt,name=application_bytes,json=applicationBytes" json:"application_bytes,omitempty"`
	Packets          *int64   `protobuf:"varint,8,opt,name=packets" json:"packets,omitempty"`
	Loss             *float32 `protobuf:"fixed32,9,opt,name=loss" json:"loss,omitempty"`
	// ---------- ICMP ----------
	Type            *int32 `protobuf:"varint,10,opt,name=type" json:"type,omitempty"`
	Code            *int32 `protobuf:"varint,11,opt,name=code" json:"code,omitempty"`
	Id              *int32 `protobuf:"varint,12,opt,name=id" json:"id,omitempty"`
	Retransmissions *int64 `protobuf:"varint,13,opt,name=retransmissions" json:"retransmissions,omitempty"`
	// The vlan_id of the packet, empty if no vlan header.
	VlanId *int32 `protobuf:"varint,14,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
	// The L2 source addresses on which we observed this flow
	SourceMac [][]byte `protobuf:"bytes,15,rep,name=source_mac,json=sourceMac" json:"source_mac,omitempty"`
	// The L2 destination addresses that were affixed to this flow
	DestinationMac [][]byte `protobuf:"bytes,16,rep,name=destination_mac,json=destinationMac" json:"destination_mac,omitempty"`
	// The physical port id(s) on which we received/sent this flow.
	PhysicalPortNumber []int32 `protobuf:"varint,17,rep,name=physical_port_number,json=physicalPortNumber" json:"physical_port_number,omitempty"`
	// If the intercepted packet is a gre packet, place the key here.
	GreKey *uint32 `protobuf:"varint,18,opt,name=gre_key,json=greKey" json:"gre_key,omitempty"`
	// If we are looking at a tunneled protocol store the inner flow information
	// here. Note, this is typically the really interesting address.
	InnerAddress *common.IPAddressWrapper `protobuf:"bytes,19,opt,name=inner_address,json=innerAddress" json:"inner_address,omitempty"`
	InnerPort    *common.IPAddressWrapper `protobuf:"bytes,20,opt,name=inner_port,json=innerPort" json:"inner_port,omitempty"`
	// as in IPPROTO_*
	InnerProtocol *common.IPAddressWrapper `protobuf:"bytes,21,opt,name=inner_protocol,json=innerProtocol" json:"inner_protocol,omitempty"`
	// We may get richer flow information, e.g., decorated with pcap info.
	// We store additional information on a per-packet basis in the
	// sequence of pcap_decoration(s) below
	// Timestamps in these are relative to the timestamp of the record.
	// Decoration is most meaningful if the flow describes something
	// like a single connection. But this is not a requirement. If we
	// get netflow records we don't get the pcap information.
	PacketDecor      []*PacketData `protobuf:"bytes,22,rep,name=packet_decor,json=packetDecor" json:"packet_decor,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *IPFlow) Reset()                    { *m = IPFlow{} }
func (m *IPFlow) String() string            { return proto.CompactTextString(m) }
func (*IPFlow) ProtoMessage()               {}
func (*IPFlow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *IPFlow) GetAddress() *common.IPAddressWrapper {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPFlow) GetMask() *common.IPAddressWrapper {
	if m != nil {
		return m.Mask
	}
	return nil
}

func (m *IPFlow) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *IPFlow) GetTos() int32 {
	if m != nil && m.Tos != nil {
		return *m.Tos
	}
	return 0
}

func (m *IPFlow) GetTtl() int32 {
	if m != nil && m.Ttl != nil {
		return *m.Ttl
	}
	return 0
}

func (m *IPFlow) GetBytes() int64 {
	if m != nil && m.Bytes != nil {
		return *m.Bytes
	}
	return 0
}

func (m *IPFlow) GetApplicationBytes() int64 {
	if m != nil && m.ApplicationBytes != nil {
		return *m.ApplicationBytes
	}
	return 0
}

func (m *IPFlow) GetPackets() int64 {
	if m != nil && m.Packets != nil {
		return *m.Packets
	}
	return 0
}

func (m *IPFlow) GetLoss() float32 {
	if m != nil && m.Loss != nil {
		return *m.Loss
	}
	return 0
}

func (m *IPFlow) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *IPFlow) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *IPFlow) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *IPFlow) GetRetransmissions() int64 {
	if m != nil && m.Retransmissions != nil {
		return *m.Retransmissions
	}
	return 0
}

func (m *IPFlow) GetVlanId() int32 {
	if m != nil && m.VlanId != nil {
		return *m.VlanId
	}
	return 0
}

func (m *IPFlow) GetSourceMac() [][]byte {
	if m != nil {
		return m.SourceMac
	}
	return nil
}

func (m *IPFlow) GetDestinationMac() [][]byte {
	if m != nil {
		return m.DestinationMac
	}
	return nil
}

func (m *IPFlow) GetPhysicalPortNumber() []int32 {
	if m != nil {
		return m.PhysicalPortNumber
	}
	return nil
}

func (m *IPFlow) GetGreKey() uint32 {
	if m != nil && m.GreKey != nil {
		return *m.GreKey
	}
	return 0
}

func (m *IPFlow) GetInnerAddress() *common.IPAddressWrapper {
	if m != nil {
		return m.InnerAddress
	}
	return nil
}

func (m *IPFlow) GetInnerPort() *common.IPAddressWrapper {
	if m != nil {
		return m.InnerPort
	}
	return nil
}

func (m *IPFlow) GetInnerProtocol() *common.IPAddressWrapper {
	if m != nil {
		return m.InnerProtocol
	}
	return nil
}

func (m *IPFlow) GetPacketDecor() []*PacketData {
	if m != nil {
		return m.PacketDecor
	}
	return nil
}

type FlowRecord struct {
	// which capture was responsible for this record.
	CaptureSpecId *int32 `protobuf:"varint,1,req,name=capture_spec_id,json=captureSpecId" json:"capture_spec_id,omitempty"`
	// seconds since epoch : deprecated use top-level instead
	TimestampSeconds *int64 `protobuf:"varint,2,opt,name=timestamp_seconds,json=timestampSeconds" json:"timestamp_seconds,omitempty"`
	// really required
	TimestampNs *uint32 `protobuf:"varint,3,opt,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	// if duration is not set then the flow-record is incomplete, i.e.,
	// the flow was started but hasn't terminated. If the record is
	// an aggregate count of many individual records then we set
	// bucket_duration_us instead of this value.
	// The field is also unset if this is a single packet.
	DurationUs *int64              `protobuf:"varint,4,opt,name=duration_us,json=durationUs" json:"duration_us,omitempty"`
	L2Proto    *FlowRecord_L2Proto `protobuf:"varint,5,opt,name=l2_proto,json=l2Proto,enum=nofutz.FlowMinder.FlowRecord_L2Proto,def=1" json:"l2_proto,omitempty"`
	// L3 protocol is recorded as ETHERTYPE
	L3Proto     *int32  `protobuf:"varint,6,opt,name=l3_proto,json=l3Proto" json:"l3_proto,omitempty"`
	L4Proto     *int32  `protobuf:"varint,7,opt,name=l4_proto,json=l4Proto" json:"l4_proto,omitempty"`
	Source      *IPFlow `protobuf:"bytes,8,opt,name=source" json:"source,omitempty"`
	Destination *IPFlow `protobuf:"bytes,9,opt,name=destination" json:"destination,omitempty"`
	// The number of individual flow records that have
	// been rolled up into this entry.
	NumberOfAggregatedFlows *int64 `protobuf:"varint,10,opt,name=number_of_aggregated_flows,json=numberOfAggregatedFlows,def=1" json:"number_of_aggregated_flows,omitempty"`
	// If we roll up many individual flows into one single bucket
	// then we need to state the duration of our bucket.
	BucketDurationUs *int64 `protobuf:"varint,11,opt,name=bucket_duration_us,json=bucketDurationUs" json:"bucket_duration_us,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FlowRecord) Reset()                    { *m = FlowRecord{} }
func (m *FlowRecord) String() string            { return proto.CompactTextString(m) }
func (*FlowRecord) ProtoMessage()               {}
func (*FlowRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

const Default_FlowRecord_L2Proto FlowRecord_L2Proto = FlowRecord_L2_ETHERNET
const Default_FlowRecord_NumberOfAggregatedFlows int64 = 1

func (m *FlowRecord) GetCaptureSpecId() int32 {
	if m != nil && m.CaptureSpecId != nil {
		return *m.CaptureSpecId
	}
	return 0
}

func (m *FlowRecord) GetTimestampSeconds() int64 {
	if m != nil && m.TimestampSeconds != nil {
		return *m.TimestampSeconds
	}
	return 0
}

func (m *FlowRecord) GetTimestampNs() uint32 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *FlowRecord) GetDurationUs() int64 {
	if m != nil && m.DurationUs != nil {
		return *m.DurationUs
	}
	return 0
}

func (m *FlowRecord) GetL2Proto() FlowRecord_L2Proto {
	if m != nil && m.L2Proto != nil {
		return *m.L2Proto
	}
	return Default_FlowRecord_L2Proto
}

func (m *FlowRecord) GetL3Proto() int32 {
	if m != nil && m.L3Proto != nil {
		return *m.L3Proto
	}
	return 0
}

func (m *FlowRecord) GetL4Proto() int32 {
	if m != nil && m.L4Proto != nil {
		return *m.L4Proto
	}
	return 0
}

func (m *FlowRecord) GetSource() *IPFlow {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *FlowRecord) GetDestination() *IPFlow {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *FlowRecord) GetNumberOfAggregatedFlows() int64 {
	if m != nil && m.NumberOfAggregatedFlows != nil {
		return *m.NumberOfAggregatedFlows
	}
	return Default_FlowRecord_NumberOfAggregatedFlows
}

func (m *FlowRecord) GetBucketDurationUs() int64 {
	if m != nil && m.BucketDurationUs != nil {
		return *m.BucketDurationUs
	}
	return 0
}

type DNSRecord struct {
	RequestingHost *common.IPAddressWrapper `protobuf:"bytes,1,opt,name=requesting_host,json=requestingHost" json:"requesting_host,omitempty"`
	DnsServer      *common.IPAddressWrapper `protobuf:"bytes,2,opt,name=dns_server,json=dnsServer" json:"dns_server,omitempty"`
	// The replies
	Ips   []*common.IPAddressWrapper `protobuf:"bytes,3,rep,name=ips" json:"ips,omitempty"`
	Cname []string                   `protobuf:"bytes,4,rep,name=cname" json:"cname,omitempty"`
	// The original question
	Query *string `protobuf:"bytes,5,opt,name=query" json:"query,omitempty"`
	// Is the reply in DNSSec form
	Dnssec           *bool  `protobuf:"varint,6,opt,name=dnssec" json:"dnssec,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DNSRecord) Reset()                    { *m = DNSRecord{} }
func (m *DNSRecord) String() string            { return proto.CompactTextString(m) }
func (*DNSRecord) ProtoMessage()               {}
func (*DNSRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DNSRecord) GetRequestingHost() *common.IPAddressWrapper {
	if m != nil {
		return m.RequestingHost
	}
	return nil
}

func (m *DNSRecord) GetDnsServer() *common.IPAddressWrapper {
	if m != nil {
		return m.DnsServer
	}
	return nil
}

func (m *DNSRecord) GetIps() []*common.IPAddressWrapper {
	if m != nil {
		return m.Ips
	}
	return nil
}

func (m *DNSRecord) GetCname() []string {
	if m != nil {
		return m.Cname
	}
	return nil
}

func (m *DNSRecord) GetQuery() string {
	if m != nil && m.Query != nil {
		return *m.Query
	}
	return ""
}

func (m *DNSRecord) GetDnssec() bool {
	if m != nil && m.Dnssec != nil {
		return *m.Dnssec
	}
	return false
}

// Should contain either a capture_spec or a record. This gives us
// the ability to parse consecutive records flexibly. The record contains
// only one of the fields, namely the one identified by record_type.
// A capture spec is a meta-record meant to describe the file at hand.
type CaptureRecordUnion struct {
	// Rough timestamp for indexing or filtering of data. May be
	// augmented internally.  In UTC since epoch.
	TimestampSeconds *int64                         `protobuf:"varint,1,opt,name=timestamp_seconds,json=timestampSeconds" json:"timestamp_seconds,omitempty"`
	RecordType       *CaptureRecordUnion_RecordType `protobuf:"varint,6,opt,name=record_type,json=recordType,enum=nofutz.FlowMinder.CaptureRecordUnion_RecordType" json:"record_type,omitempty"`
	CaptureSpec      *common.CaptureSpec            `protobuf:"bytes,7,opt,name=capture_spec,json=captureSpec" json:"capture_spec,omitempty"`
	FlowRecord       *FlowRecord                    `protobuf:"bytes,8,opt,name=flow_record,json=flowRecord" json:"flow_record,omitempty"`
	BgpUpdateRecord  *bgp.BGPUpdate                 `protobuf:"bytes,9,opt,name=bgp_update_record,json=bgpUpdateRecord" json:"bgp_update_record,omitempty"`
	DnsRecord        *DNSRecord                     `protobuf:"bytes,10,opt,name=dns_record,json=dnsRecord" json:"dns_record,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *CaptureRecordUnion) Reset()                    { *m = CaptureRecordUnion{} }
func (m *CaptureRecordUnion) String() string            { return proto.CompactTextString(m) }
func (*CaptureRecordUnion) ProtoMessage()               {}
func (*CaptureRecordUnion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CaptureRecordUnion) GetTimestampSeconds() int64 {
	if m != nil && m.TimestampSeconds != nil {
		return *m.TimestampSeconds
	}
	return 0
}

func (m *CaptureRecordUnion) GetRecordType() CaptureRecordUnion_RecordType {
	if m != nil && m.RecordType != nil {
		return *m.RecordType
	}
	return CaptureRecordUnion_CAPTURE_SPEC
}

func (m *CaptureRecordUnion) GetCaptureSpec() *common.CaptureSpec {
	if m != nil {
		return m.CaptureSpec
	}
	return nil
}

func (m *CaptureRecordUnion) GetFlowRecord() *FlowRecord {
	if m != nil {
		return m.FlowRecord
	}
	return nil
}

func (m *CaptureRecordUnion) GetBgpUpdateRecord() *bgp.BGPUpdate {
	if m != nil {
		return m.BgpUpdateRecord
	}
	return nil
}

func (m *CaptureRecordUnion) GetDnsRecord() *DNSRecord {
	if m != nil {
		return m.DnsRecord
	}
	return nil
}

func init() {
	proto.RegisterType((*PacketData)(nil), "nofutz.FlowMinder.PacketData")
	proto.RegisterType((*IPFlow)(nil), "nofutz.FlowMinder.IPFlow")
	proto.RegisterType((*FlowRecord)(nil), "nofutz.FlowMinder.FlowRecord")
	proto.RegisterType((*DNSRecord)(nil), "nofutz.FlowMinder.DNSRecord")
	proto.RegisterType((*CaptureRecordUnion)(nil), "nofutz.FlowMinder.CaptureRecordUnion")
	proto.RegisterEnum("nofutz.FlowMinder.FlowRecord_L2Proto", FlowRecord_L2Proto_name, FlowRecord_L2Proto_value)
	proto.RegisterEnum("nofutz.FlowMinder.CaptureRecordUnion_RecordType", CaptureRecordUnion_RecordType_name, CaptureRecordUnion_RecordType_value)
}

func init() {
	proto.RegisterFile("github.com/CSUNetSec/netsec-protobufs/netbrane/netbrane.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1263 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x56, 0xeb, 0x72, 0x13, 0xc7,
	0x12, 0x3e, 0xd2, 0xea, 0x62, 0xf5, 0xca, 0xb2, 0x3c, 0xe6, 0xb2, 0xb8, 0x0e, 0x75, 0x74, 0x54,
	0x95, 0xa0, 0xdc, 0x04, 0xc8, 0xae, 0xa4, 0x02, 0x81, 0xc4, 0xb6, 0x04, 0xb8, 0x62, 0x64, 0x65,
	0x64, 0x87, 0x9f, 0x53, 0xab, 0xdd, 0x91, 0xd8, 0xb2, 0x34, 0xbb, 0xcc, 0xcc, 0x42, 0x89, 0x67,
	0xc9, 0x4b, 0xe4, 0x81, 0x52, 0x79, 0x8c, 0xfc, 0x4d, 0x4d, 0xcf, 0xea, 0x42, 0x70, 0x6c, 0x7e,
	0x50, 0xf4, 0x7c, 0xdd, 0x3d, 0xdb, 0xf3, 0xf5, 0xd7, 0x6d, 0xc1, 0x93, 0x49, 0xa4, 0x5f, 0xa7,
	0xa3, 0x76, 0x10, 0xcf, 0xee, 0x1f, 0x0d, 0xcf, 0xfb, 0x5c, 0x0f, 0x79, 0x70, 0x5f, 0x70, 0xad,
	0x78, 0xf0, 0x4d, 0x22, 0x63, 0x1d, 0x8f, 0xd2, 0xb1, 0x32, 0xc0, 0x48, 0xfa, 0x82, 0x2f, 0x8d,
	0x36, 0xfa, 0xc8, 0xb6, 0x88, 0xc7, 0xa9, 0x7e, 0xdf, 0x7e, 0x36, 0x8d, 0xdf, 0xbd, 0x8c, 0x44,
	0xc8, 0xe5, 0xee, 0xf7, 0x9f, 0x76, 0x63, 0x10, 0xcf, 0x66, 0xb1, 0xc8, 0xfe, 0xb3, 0xb7, 0xed,
	0xfe, 0xf0, 0x69, 0xa9, 0x68, 0x05, 0xf1, 0xf4, 0xfe, 0x68, 0x92, 0x98, 0x7f, 0x36, 0xbb, 0xf9,
	0x67, 0x1e, 0x60, 0xe0, 0x07, 0x17, 0x5c, 0x77, 0x7d, 0xed, 0x93, 0x3d, 0xb8, 0x25, 0x7c, 0x11,
	0x2b, 0xa6, 0x22, 0x11, 0x70, 0x36, 0x9e, 0xc6, 0xef, 0x98, 0xd2, 0xbe, 0xd4, 0x5e, 0xae, 0x91,
	0x6b, 0x15, 0xe8, 0x0e, 0x7a, 0x87, 0xc6, 0x69, 0xaa, 0x1f, 0x1a, 0x17, 0xf9, 0x1f, 0xb8, 0x09,
	0x5e, 0xc1, 0x54, 0xf4, 0x9e, 0x7b, 0xf9, 0x46, 0xae, 0xb5, 0x49, 0xc1, 0x42, 0xc3, 0xe8, 0x3d,
	0x27, 0x3b, 0x50, 0x8c, 0x12, 0x16, 0x85, 0x9e, 0x83, 0xae, 0x42, 0x94, 0x1c, 0x87, 0x26, 0x2b,
	0x52, 0x6c, 0x2c, 0xfd, 0xc9, 0x8c, 0x0b, 0xed, 0x15, 0x1a, 0xb9, 0xd6, 0x06, 0x85, 0x48, 0x3d,
	0xcb, 0x10, 0x13, 0xf0, 0x2e, 0x12, 0xa1, 0xa9, 0xc0, 0x5c, 0x5b, 0x6c, 0xe4, 0x5a, 0x45, 0x0a,
	0x16, 0xc2, 0x6b, 0x77, 0x61, 0x43, 0xf1, 0x37, 0x29, 0x17, 0x01, 0xf7, 0x4a, 0x78, 0xf3, 0xf2,
	0x4c, 0xea, 0xe0, 0xf8, 0xc1, 0x85, 0x57, 0x46, 0xd8, 0x98, 0x06, 0x51, 0x73, 0xe1, 0x6d, 0xe0,
	0x77, 0x8c, 0x69, 0x90, 0x71, 0x24, 0xbc, 0x8a, 0x45, 0xc6, 0x91, 0x20, 0x37, 0xa0, 0x28, 0xb9,
	0xe2, 0xda, 0x03, 0xc4, 0xec, 0x81, 0xdc, 0x05, 0x88, 0x13, 0x1d, 0xc5, 0x42, 0xb1, 0xe9, 0x9e,
	0xe7, 0xa2, 0xab, 0x92, 0x21, 0x27, 0x7b, 0x1f, 0xb8, 0xf7, 0xbd, 0xea, 0x87, 0xee, 0xfd, 0xe6,
	0x6f, 0x25, 0x28, 0x1d, 0x0f, 0x0c, 0x5b, 0xa4, 0x03, 0x65, 0x3f, 0x0c, 0x25, 0x57, 0x0a, 0xe9,
	0x74, 0x3b, 0x5e, 0x3b, 0x6b, 0xe5, 0xf1, 0xe0, 0xc0, 0x3a, 0x5e, 0x49, 0x3f, 0x49, 0xb8, 0xa4,
	0x8b, 0x40, 0xf2, 0x35, 0x14, 0x66, 0xbe, 0xba, 0x40, 0x56, 0xaf, 0x4a, 0xc0, 0x28, 0x42, 0xa0,
	0x90, 0xc4, 0x52, 0x23, 0xd1, 0x45, 0x8a, 0xb6, 0x79, 0xa6, 0x8e, 0x15, 0x12, 0x5c, 0xa4, 0xc6,
	0x44, 0x44, 0x4f, 0x33, 0x46, 0x8d, 0x69, 0x1e, 0x3e, 0x9a, 0x6b, 0xae, 0x90, 0x47, 0x87, 0xda,
	0x03, 0xf9, 0x0a, 0xb6, 0xfd, 0x24, 0x99, 0x46, 0x81, 0x6f, 0x1e, 0xc3, 0x6c, 0x44, 0x19, 0x23,
	0xea, 0x6b, 0x8e, 0x43, 0x0c, 0xf6, 0xa0, 0x6c, 0x5b, 0xae, 0x90, 0x63, 0x87, 0x2e, 0x8e, 0xa6,
	0xa8, 0x69, 0xac, 0x14, 0x12, 0x9d, 0xa7, 0x68, 0x1b, 0x4c, 0xcf, 0x13, 0x8e, 0x44, 0x17, 0x29,
	0xda, 0x06, 0x0b, 0xe2, 0x90, 0x23, 0xc3, 0x45, 0x8a, 0x36, 0xa9, 0x41, 0x3e, 0x0a, 0x91, 0xd4,
	0x22, 0xcd, 0x47, 0x21, 0x69, 0xc1, 0x96, 0xe4, 0x5a, 0xfa, 0x42, 0xcd, 0x22, 0xa5, 0x0c, 0xc5,
	0xde, 0x26, 0x7e, 0xed, 0x9f, 0x30, 0xb9, 0x0d, 0xe5, 0xb7, 0x53, 0x5f, 0x18, 0xd9, 0xd5, 0x30,
	0xbd, 0x64, 0x8e, 0xc7, 0xa1, 0xe9, 0x97, 0x8a, 0x53, 0x19, 0x70, 0x36, 0xf3, 0x03, 0x6f, 0xab,
	0xe1, 0xb4, 0xaa, 0xb4, 0x62, 0x91, 0x97, 0x7e, 0x40, 0xee, 0xc1, 0x56, 0xc8, 0x95, 0x8e, 0x84,
	0x7d, 0xb4, 0x89, 0xa9, 0x63, 0x4c, 0x6d, 0x0d, 0x36, 0x81, 0x0f, 0xe0, 0x46, 0xf2, 0x7a, 0xae,
	0xa2, 0xc0, 0x9f, 0x32, 0x43, 0x34, 0x13, 0xe9, 0x6c, 0xc4, 0xa5, 0xb7, 0xdd, 0x70, 0x5a, 0x45,
	0x4a, 0x16, 0xbe, 0x41, 0x2c, 0x75, 0x1f, 0x3d, 0xa6, 0xa4, 0x89, 0xe4, 0xec, 0x82, 0xcf, 0x3d,
	0x82, 0xc2, 0x2c, 0x4d, 0x24, 0xff, 0x99, 0xcf, 0xc9, 0x13, 0xd8, 0x8c, 0x84, 0xe0, 0x92, 0x2d,
	0xe4, 0xb1, 0x73, 0x4d, 0xb7, 0xab, 0x18, 0x9e, 0x81, 0xe4, 0x3b, 0x00, 0x9b, 0x8e, 0xbd, 0xbf,
	0x71, 0x4d, 0x6e, 0x05, 0x63, 0x4d, 0x59, 0xe4, 0x47, 0xa8, 0x65, 0x89, 0xd9, 0x76, 0xf0, 0x6e,
	0x5e, 0x93, 0x6c, 0xeb, 0x1c, 0x64, 0xe1, 0xe4, 0x27, 0xa8, 0x66, 0xa3, 0x1f, 0xf2, 0x20, 0x96,
	0xde, 0xad, 0x86, 0xd3, 0x72, 0x3b, 0x77, 0xdb, 0x1f, 0x6d, 0xb8, 0xf6, 0x6a, 0xc9, 0xd0, 0x6c,
	0x5b, 0x74, 0x4d, 0x46, 0xf3, 0xf7, 0x02, 0x80, 0x09, 0xa3, 0xe6, 0x14, 0x92, 0xcf, 0x61, 0x2b,
	0xf0, 0x13, 0x9d, 0x4a, 0xce, 0x54, 0xc2, 0x03, 0xd3, 0xbd, 0x5c, 0x23, 0xdf, 0x2a, 0xd2, 0xcd,
	0x0c, 0x1e, 0x26, 0x3c, 0x38, 0x0e, 0x8d, 0x34, 0x75, 0x34, 0xe3, 0x4a, 0xfb, 0xb3, 0x84, 0x29,
	0x1e, 0xc4, 0x22, 0x54, 0x38, 0x23, 0x0e, 0xad, 0x2f, 0x1d, 0x43, 0x8b, 0x93, 0xff, 0x43, 0x75,
	0x15, 0x2c, 0x54, 0xb6, 0x86, 0xdc, 0x25, 0xd6, 0x57, 0x66, 0xd9, 0x84, 0xa9, 0xb4, 0x2d, 0x4f,
	0xed, 0xb0, 0x38, 0x14, 0x16, 0xd0, 0xb9, 0x22, 0x2f, 0x61, 0x63, 0xda, 0xb1, 0x3c, 0xe1, 0xe0,
	0xd4, 0x3a, 0x9f, 0x5d, 0xf2, 0xca, 0xd5, 0x4b, 0xda, 0x27, 0x1d, 0x64, 0xe9, 0x91, 0x7b, 0xd2,
	0x61, 0xbd, 0xb3, 0x17, 0x3d, 0xda, 0xef, 0x9d, 0xd1, 0xf2, 0xd4, 0xa2, 0xe4, 0x0e, 0x6c, 0x4c,
	0xf7, 0xb2, 0xeb, 0x4a, 0x28, 0xcf, 0xf2, 0x74, 0x6f, 0xe5, 0xda, 0xcf, 0x5c, 0xe5, 0xcc, 0xb5,
	0x6f, 0x5d, 0x0f, 0xa1, 0x64, 0x85, 0x8a, 0x23, 0xe6, 0x76, 0xee, 0x5c, 0x52, 0x82, 0xdd, 0x35,
	0x34, 0x0b, 0x24, 0x8f, 0xc1, 0x5d, 0xd3, 0x2d, 0xce, 0xe0, 0x95, 0x79, 0xeb, 0xd1, 0xe4, 0x29,
	0xec, 0x5a, 0x51, 0xb3, 0x78, 0xcc, 0xfc, 0xc9, 0x44, 0xf2, 0x89, 0xaf, 0x79, 0x88, 0x7f, 0x17,
	0x14, 0xce, 0xae, 0xf3, 0x28, 0xf7, 0x90, 0xde, 0xb6, 0x41, 0xa7, 0xe3, 0x83, 0x65, 0x88, 0xb9,
	0xcb, 0x2c, 0x2f, 0x32, 0x4a, 0xad, 0x3c, 0xd6, 0xc8, 0x75, 0x6d, 0x9b, 0xac, 0xa7, 0xbb, 0xa4,
	0xb8, 0x79, 0x0f, 0xca, 0x19, 0x69, 0xc4, 0x35, 0x26, 0xeb, 0x9f, 0xf6, 0x7b, 0xf5, 0xff, 0x90,
	0x2d, 0x58, 0xe7, 0xb0, 0x9e, 0x6b, 0xfe, 0x95, 0x83, 0x4a, 0xb7, 0x3f, 0xcc, 0x24, 0x73, 0x60,
	0x56, 0xc2, 0x9b, 0x14, 0xcb, 0x9e, 0xb0, 0xd7, 0xb1, 0xd2, 0xd7, 0x6e, 0xd7, 0xda, 0x2a, 0xe1,
	0x45, 0xac, 0xb4, 0x19, 0xa0, 0x50, 0x28, 0xa6, 0xb8, 0x7c, 0xcb, 0xe5, 0xb5, 0xab, 0xb6, 0x12,
	0x0a, 0x35, 0xc4, 0x50, 0xf2, 0x25, 0x38, 0x51, 0x62, 0x04, 0xe5, 0x5c, 0x99, 0x61, 0x82, 0xcc,
	0x8e, 0x0d, 0x84, 0x3f, 0xe3, 0x5e, 0xa1, 0xe1, 0xb4, 0x2a, 0xd4, 0x1e, 0x0c, 0xfa, 0x26, 0xe5,
	0x72, 0x8e, 0xa2, 0xaa, 0x50, 0x7b, 0x20, 0xb7, 0xa0, 0x14, 0x0a, 0xa5, 0x78, 0x80, 0xe2, 0xd8,
	0xa0, 0xd9, 0xa9, 0xf9, 0x87, 0x03, 0xe4, 0xc8, 0x0e, 0x82, 0x7d, 0xfd, 0xb9, 0x30, 0x7d, 0xba,
	0x74, 0x1a, 0x72, 0xff, 0x32, 0x0d, 0xbf, 0x80, 0x2b, 0x31, 0x97, 0xe1, 0x06, 0x2e, 0xa1, 0x98,
	0x1f, 0x5c, 0xa2, 0x88, 0x8f, 0x3f, 0xd4, 0xb6, 0xf6, 0xd9, 0x3c, 0xe1, 0x14, 0xe4, 0xd2, 0x26,
	0xdf, 0x42, 0x75, 0x7d, 0x6a, 0x51, 0xb6, 0x6e, 0x67, 0x67, 0xc1, 0xc7, 0xd1, 0x6a, 0x74, 0xa9,
	0xbb, 0x36, 0xc7, 0xe4, 0x29, 0xb8, 0xf8, 0x13, 0xc3, 0x5e, 0x95, 0x89, 0xfa, 0xee, 0x95, 0x73,
	0x45, 0x61, 0xbc, 0xda, 0x16, 0x8f, 0x60, 0x7b, 0x34, 0x49, 0x58, 0x9a, 0x84, 0xbe, 0xe6, 0x8b,
	0x5b, 0xac, 0xc4, 0x6b, 0x6d, 0xf3, 0x23, 0xe7, 0xf0, 0xf9, 0xe0, 0x1c, 0x9d, 0x74, 0x6b, 0x34,
	0x49, 0x32, 0xd3, 0xe6, 0x3e, 0xb6, 0x3d, 0xcf, 0x92, 0x00, 0x93, 0xfe, 0x7b, 0xc9, 0xa7, 0x97,
	0x42, 0xc3, 0xbe, 0x5b, 0xb3, 0xf9, 0x2b, 0xc0, 0x8a, 0x0a, 0x52, 0x87, 0xea, 0xd1, 0xc1, 0xe0,
	0xec, 0x9c, 0xf6, 0xd8, 0x70, 0xd0, 0x3b, 0xaa, 0xe7, 0x8c, 0x64, 0x9f, 0x9d, 0x9c, 0xbe, 0x62,
	0xb4, 0x77, 0x74, 0x4a, 0xbb, 0xf5, 0x3c, 0xb9, 0x09, 0xdb, 0x87, 0xcf, 0x07, 0xec, 0x7c, 0xd0,
	0x3d, 0x38, 0xeb, 0x2d, 0x60, 0x87, 0xd4, 0x00, 0xba, 0xfd, 0xe1, 0xe2, 0x5c, 0x38, 0xfc, 0x02,
	0x6e, 0x06, 0xf1, 0x6c, 0x51, 0x85, 0x79, 0xe9, 0x0c, 0xab, 0x38, 0xac, 0xaf, 0x2a, 0xc2, 0x09,
	0x51, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x7d, 0x89, 0x23, 0x61, 0x85, 0x0a, 0x00, 0x00,
}
