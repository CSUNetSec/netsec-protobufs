// Code generated by protoc-gen-go.
// source: github.com/CSUNetSec/netsec-protobufs/netbrane/netbrane.proto
// DO NOT EDIT!

/*
Package netbrane is a generated protocol buffer package.

It is generated from these files:
	github.com/CSUNetSec/netsec-protobufs/netbrane/netbrane.proto

It has these top-level messages:
	PacketData
	IPFlow
	FlowRecord
	DNSRecord
	CaptureRecordUnion
*/
package netbrane

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "github.com/CSUNetSec/netsec-protobufs/common"
import bgp "github.com/CSUNetSec/netsec-protobufs/protocol/bgp"
import proddle "github.com/CSUNetSec/netsec-protobufs/proddle"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FlowRecord_L2Proto int32

const (
	FlowRecord_L2_NONE     FlowRecord_L2Proto = 0
	FlowRecord_L2_ETHERNET FlowRecord_L2Proto = 1
)

var FlowRecord_L2Proto_name = map[int32]string{
	0: "L2_NONE",
	1: "L2_ETHERNET",
}
var FlowRecord_L2Proto_value = map[string]int32{
	"L2_NONE":     0,
	"L2_ETHERNET": 1,
}

func (x FlowRecord_L2Proto) String() string {
	return proto.EnumName(FlowRecord_L2Proto_name, int32(x))
}
func (FlowRecord_L2Proto) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type CaptureRecordUnion_RecordType int32

const (
	CaptureRecordUnion_CAPTURE_SPEC        CaptureRecordUnion_RecordType = 0
	CaptureRecordUnion_FLOW_RECORD         CaptureRecordUnion_RecordType = 1
	CaptureRecordUnion_BGP_UPDATE_RECORD   CaptureRecordUnion_RecordType = 2
	CaptureRecordUnion_DNS_RECORD          CaptureRecordUnion_RecordType = 3
	CaptureRecordUnion_PROBE_RECORD        CaptureRecordUnion_RecordType = 4
	CaptureRecordUnion_PROBE_RESULT_RECORD CaptureRecordUnion_RecordType = 5
)

var CaptureRecordUnion_RecordType_name = map[int32]string{
	0: "CAPTURE_SPEC",
	1: "FLOW_RECORD",
	2: "BGP_UPDATE_RECORD",
	3: "DNS_RECORD",
	4: "PROBE_RECORD",
	5: "PROBE_RESULT_RECORD",
}
var CaptureRecordUnion_RecordType_value = map[string]int32{
	"CAPTURE_SPEC":        0,
	"FLOW_RECORD":         1,
	"BGP_UPDATE_RECORD":   2,
	"DNS_RECORD":          3,
	"PROBE_RECORD":        4,
	"PROBE_RESULT_RECORD": 5,
}

func (x CaptureRecordUnion_RecordType) String() string {
	return proto.EnumName(CaptureRecordUnion_RecordType_name, int32(x))
}
func (CaptureRecordUnion_RecordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

// We don't always capture packet data. If we do, this is
// the format
type PacketData struct {
	NanosSinceFlowStart uint64 `protobuf:"varint,1,opt,name=nanos_since_flow_start,json=nanosSinceFlowStart" json:"nanos_since_flow_start,omitempty"`
	PacketSize          uint32 `protobuf:"varint,2,opt,name=packet_size,json=packetSize" json:"packet_size,omitempty"`
	// IP per packet see RFC 791
	IpId uint32 `protobuf:"varint,3,opt,name=ip_id,json=ipId" json:"ip_id,omitempty"`
	// either more fragments after this or offset != 0
	IsFragment bool `protobuf:"varint,4,opt,name=is_fragment,json=isFragment" json:"is_fragment,omitempty"`
	// TCP related follows RFC 793
	// This is the window advertisement
	// in bytes.
	WindowSize int32  `protobuf:"varint,5,opt,name=window_size,json=windowSize" json:"window_size,omitempty"`
	Sequence   uint32 `protobuf:"varint,6,opt,name=sequence" json:"sequence,omitempty"`
	Ack        uint32 `protobuf:"varint,7,opt,name=ack" json:"ack,omitempty"`
	Syn        bool   `protobuf:"varint,8,opt,name=syn" json:"syn,omitempty"`
	Fin        bool   `protobuf:"varint,9,opt,name=fin" json:"fin,omitempty"`
	Reset_     bool   `protobuf:"varint,10,opt,name=reset" json:"reset,omitempty"`
	// Do we need more understanding of options ip and otherwise
	OptionsL3 bool `protobuf:"varint,11,opt,name=options_l3,json=optionsL3" json:"options_l3,omitempty"`
	OptionsL4 bool `protobuf:"varint,12,opt,name=options_l4,json=optionsL4" json:"options_l4,omitempty"`
}

func (m *PacketData) Reset()                    { *m = PacketData{} }
func (m *PacketData) String() string            { return proto.CompactTextString(m) }
func (*PacketData) ProtoMessage()               {}
func (*PacketData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PacketData) GetNanosSinceFlowStart() uint64 {
	if m != nil {
		return m.NanosSinceFlowStart
	}
	return 0
}

func (m *PacketData) GetPacketSize() uint32 {
	if m != nil {
		return m.PacketSize
	}
	return 0
}

func (m *PacketData) GetIpId() uint32 {
	if m != nil {
		return m.IpId
	}
	return 0
}

func (m *PacketData) GetIsFragment() bool {
	if m != nil {
		return m.IsFragment
	}
	return false
}

func (m *PacketData) GetWindowSize() int32 {
	if m != nil {
		return m.WindowSize
	}
	return 0
}

func (m *PacketData) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *PacketData) GetAck() uint32 {
	if m != nil {
		return m.Ack
	}
	return 0
}

func (m *PacketData) GetSyn() bool {
	if m != nil {
		return m.Syn
	}
	return false
}

func (m *PacketData) GetFin() bool {
	if m != nil {
		return m.Fin
	}
	return false
}

func (m *PacketData) GetReset_() bool {
	if m != nil {
		return m.Reset_
	}
	return false
}

func (m *PacketData) GetOptionsL3() bool {
	if m != nil {
		return m.OptionsL3
	}
	return false
}

func (m *PacketData) GetOptionsL4() bool {
	if m != nil {
		return m.OptionsL4
	}
	return false
}

// Flow originates at address
type IPFlow struct {
	// really required
	Address *common.IPAddressWrapper `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// we may aggregate flows for an entire subnet if we
	// get too fine-grained with individual flow records.
	Mask  *common.IPAddressWrapper `protobuf:"bytes,2,opt,name=mask" json:"mask,omitempty"`
	Port  int32                    `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
	Tos   int32                    `protobuf:"varint,4,opt,name=tos" json:"tos,omitempty"`
	Ttl   int32                    `protobuf:"varint,5,opt,name=ttl" json:"ttl,omitempty"`
	Bytes int64                    `protobuf:"varint,6,opt,name=bytes" json:"bytes,omitempty"`
	// Some sniffers may be able to parse the number of acutal payload bytes
	ApplicationBytes int64   `protobuf:"varint,7,opt,name=application_bytes,json=applicationBytes" json:"application_bytes,omitempty"`
	Packets          int64   `protobuf:"varint,8,opt,name=packets" json:"packets,omitempty"`
	Loss             float32 `protobuf:"fixed32,9,opt,name=loss" json:"loss,omitempty"`
	// ---------- ICMP ----------
	Type            int32 `protobuf:"varint,10,opt,name=type" json:"type,omitempty"`
	Code            int32 `protobuf:"varint,11,opt,name=code" json:"code,omitempty"`
	Id              int32 `protobuf:"varint,12,opt,name=id" json:"id,omitempty"`
	Retransmissions int64 `protobuf:"varint,13,opt,name=retransmissions" json:"retransmissions,omitempty"`
	// The vlan_id of the packet, empty if no vlan header.
	VlanId int32 `protobuf:"varint,14,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
	// The L2 source addresses on which we observed this flow
	SourceMac [][]byte `protobuf:"bytes,15,rep,name=source_mac,json=sourceMac,proto3" json:"source_mac,omitempty"`
	// The L2 destination addresses that were affixed to this flow
	DestinationMac [][]byte `protobuf:"bytes,16,rep,name=destination_mac,json=destinationMac,proto3" json:"destination_mac,omitempty"`
	// The physical port id(s) on which we received/sent this flow.
	PhysicalPortNumber []int32 `protobuf:"varint,17,rep,packed,name=physical_port_number,json=physicalPortNumber" json:"physical_port_number,omitempty"`
	// If the intercepted packet is a gre packet, place the key here.
	GreKey uint32 `protobuf:"varint,18,opt,name=gre_key,json=greKey" json:"gre_key,omitempty"`
	// If we are looking at a tunneled protocol store the inner flow information
	// here. Note, this is typically the really interesting address.
	InnerAddress *common.IPAddressWrapper `protobuf:"bytes,19,opt,name=inner_address,json=innerAddress" json:"inner_address,omitempty"`
	InnerPort    *common.IPAddressWrapper `protobuf:"bytes,20,opt,name=inner_port,json=innerPort" json:"inner_port,omitempty"`
	// as in IPPROTO_*
	InnerProtocol *common.IPAddressWrapper `protobuf:"bytes,21,opt,name=inner_protocol,json=innerProtocol" json:"inner_protocol,omitempty"`
	// We may get richer flow information, e.g., decorated with pcap info.
	// We store additional information on a per-packet basis in the
	// sequence of pcap_decoration(s) below
	// Timestamps in these are relative to the timestamp of the record.
	// Decoration is most meaningful if the flow describes something
	// like a single connection. But this is not a requirement. If we
	// get netflow records we don't get the pcap information.
	PacketDecor []*PacketData `protobuf:"bytes,22,rep,name=packet_decor,json=packetDecor" json:"packet_decor,omitempty"`
}

func (m *IPFlow) Reset()                    { *m = IPFlow{} }
func (m *IPFlow) String() string            { return proto.CompactTextString(m) }
func (*IPFlow) ProtoMessage()               {}
func (*IPFlow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *IPFlow) GetAddress() *common.IPAddressWrapper {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPFlow) GetMask() *common.IPAddressWrapper {
	if m != nil {
		return m.Mask
	}
	return nil
}

func (m *IPFlow) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *IPFlow) GetTos() int32 {
	if m != nil {
		return m.Tos
	}
	return 0
}

func (m *IPFlow) GetTtl() int32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *IPFlow) GetBytes() int64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

func (m *IPFlow) GetApplicationBytes() int64 {
	if m != nil {
		return m.ApplicationBytes
	}
	return 0
}

func (m *IPFlow) GetPackets() int64 {
	if m != nil {
		return m.Packets
	}
	return 0
}

func (m *IPFlow) GetLoss() float32 {
	if m != nil {
		return m.Loss
	}
	return 0
}

func (m *IPFlow) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *IPFlow) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *IPFlow) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *IPFlow) GetRetransmissions() int64 {
	if m != nil {
		return m.Retransmissions
	}
	return 0
}

func (m *IPFlow) GetVlanId() int32 {
	if m != nil {
		return m.VlanId
	}
	return 0
}

func (m *IPFlow) GetSourceMac() [][]byte {
	if m != nil {
		return m.SourceMac
	}
	return nil
}

func (m *IPFlow) GetDestinationMac() [][]byte {
	if m != nil {
		return m.DestinationMac
	}
	return nil
}

func (m *IPFlow) GetPhysicalPortNumber() []int32 {
	if m != nil {
		return m.PhysicalPortNumber
	}
	return nil
}

func (m *IPFlow) GetGreKey() uint32 {
	if m != nil {
		return m.GreKey
	}
	return 0
}

func (m *IPFlow) GetInnerAddress() *common.IPAddressWrapper {
	if m != nil {
		return m.InnerAddress
	}
	return nil
}

func (m *IPFlow) GetInnerPort() *common.IPAddressWrapper {
	if m != nil {
		return m.InnerPort
	}
	return nil
}

func (m *IPFlow) GetInnerProtocol() *common.IPAddressWrapper {
	if m != nil {
		return m.InnerProtocol
	}
	return nil
}

func (m *IPFlow) GetPacketDecor() []*PacketData {
	if m != nil {
		return m.PacketDecor
	}
	return nil
}

type FlowRecord struct {
	// which capture was responsible for this record.
	CaptureSpecId int32 `protobuf:"varint,1,opt,name=capture_spec_id,json=captureSpecId" json:"capture_spec_id,omitempty"`
	// seconds since epoch : deprecated use top-level instead
	TimestampSeconds int64 `protobuf:"varint,2,opt,name=timestamp_seconds,json=timestampSeconds" json:"timestamp_seconds,omitempty"`
	// really required
	TimestampNs uint32 `protobuf:"varint,3,opt,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	// if duration is not set then the flow-record is incomplete, i.e.,
	// the flow was started but hasn't terminated. If the record is
	// an aggregate count of many individual records then we set
	// bucket_duration_us instead of this value.
	// The field is also unset if this is a single packet.
	DurationUs int64              `protobuf:"varint,4,opt,name=duration_us,json=durationUs" json:"duration_us,omitempty"`
	L2Proto    FlowRecord_L2Proto `protobuf:"varint,5,opt,name=l2_proto,json=l2Proto,enum=netbrane.FlowRecord_L2Proto" json:"l2_proto,omitempty"`
	// L3 protocol is recorded as ETHERTYPE
	L3Proto     int32   `protobuf:"varint,6,opt,name=l3_proto,json=l3Proto" json:"l3_proto,omitempty"`
	L4Proto     int32   `protobuf:"varint,7,opt,name=l4_proto,json=l4Proto" json:"l4_proto,omitempty"`
	Source      *IPFlow `protobuf:"bytes,8,opt,name=source" json:"source,omitempty"`
	Destination *IPFlow `protobuf:"bytes,9,opt,name=destination" json:"destination,omitempty"`
	// The number of individual flow records that have
	// been rolled up into this entry.
	NumberOfAggregatedFlows int64 `protobuf:"varint,10,opt,name=number_of_aggregated_flows,json=numberOfAggregatedFlows" json:"number_of_aggregated_flows,omitempty"`
	// If we roll up many individual flows into one single bucket
	// then we need to state the duration of our bucket.
	BucketDurationUs int64 `protobuf:"varint,11,opt,name=bucket_duration_us,json=bucketDurationUs" json:"bucket_duration_us,omitempty"`
}

func (m *FlowRecord) Reset()                    { *m = FlowRecord{} }
func (m *FlowRecord) String() string            { return proto.CompactTextString(m) }
func (*FlowRecord) ProtoMessage()               {}
func (*FlowRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *FlowRecord) GetCaptureSpecId() int32 {
	if m != nil {
		return m.CaptureSpecId
	}
	return 0
}

func (m *FlowRecord) GetTimestampSeconds() int64 {
	if m != nil {
		return m.TimestampSeconds
	}
	return 0
}

func (m *FlowRecord) GetTimestampNs() uint32 {
	if m != nil {
		return m.TimestampNs
	}
	return 0
}

func (m *FlowRecord) GetDurationUs() int64 {
	if m != nil {
		return m.DurationUs
	}
	return 0
}

func (m *FlowRecord) GetL2Proto() FlowRecord_L2Proto {
	if m != nil {
		return m.L2Proto
	}
	return FlowRecord_L2_NONE
}

func (m *FlowRecord) GetL3Proto() int32 {
	if m != nil {
		return m.L3Proto
	}
	return 0
}

func (m *FlowRecord) GetL4Proto() int32 {
	if m != nil {
		return m.L4Proto
	}
	return 0
}

func (m *FlowRecord) GetSource() *IPFlow {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *FlowRecord) GetDestination() *IPFlow {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *FlowRecord) GetNumberOfAggregatedFlows() int64 {
	if m != nil {
		return m.NumberOfAggregatedFlows
	}
	return 0
}

func (m *FlowRecord) GetBucketDurationUs() int64 {
	if m != nil {
		return m.BucketDurationUs
	}
	return 0
}

type DNSRecord struct {
	RequestingHost *common.IPAddressWrapper `protobuf:"bytes,1,opt,name=requesting_host,json=requestingHost" json:"requesting_host,omitempty"`
	DnsServer      *common.IPAddressWrapper `protobuf:"bytes,2,opt,name=dns_server,json=dnsServer" json:"dns_server,omitempty"`
	// The replies
	Ips   []*common.IPAddressWrapper `protobuf:"bytes,3,rep,name=ips" json:"ips,omitempty"`
	Cname []string                   `protobuf:"bytes,4,rep,name=cname" json:"cname,omitempty"`
	// The original question
	Query string `protobuf:"bytes,5,opt,name=query" json:"query,omitempty"`
	// Is the reply in DNSSec form
	Dnssec bool `protobuf:"varint,6,opt,name=dnssec" json:"dnssec,omitempty"`
}

func (m *DNSRecord) Reset()                    { *m = DNSRecord{} }
func (m *DNSRecord) String() string            { return proto.CompactTextString(m) }
func (*DNSRecord) ProtoMessage()               {}
func (*DNSRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DNSRecord) GetRequestingHost() *common.IPAddressWrapper {
	if m != nil {
		return m.RequestingHost
	}
	return nil
}

func (m *DNSRecord) GetDnsServer() *common.IPAddressWrapper {
	if m != nil {
		return m.DnsServer
	}
	return nil
}

func (m *DNSRecord) GetIps() []*common.IPAddressWrapper {
	if m != nil {
		return m.Ips
	}
	return nil
}

func (m *DNSRecord) GetCname() []string {
	if m != nil {
		return m.Cname
	}
	return nil
}

func (m *DNSRecord) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *DNSRecord) GetDnssec() bool {
	if m != nil {
		return m.Dnssec
	}
	return false
}

// Should contain either a capture_spec or a record. This gives us
// the ability to parse consecutive records flexibly. The record contains
// only one of the fields, namely the one identified by record_type.
// A capture spec is a meta-record meant to describe the file at hand.
type CaptureRecordUnion struct {
	// Rough timestamp for indexing or filtering of data. May be
	// augmented internally.  In UTC since epoch.
	TimestampSeconds  int64                         `protobuf:"varint,1,opt,name=timestamp_seconds,json=timestampSeconds" json:"timestamp_seconds,omitempty"`
	RecordType        CaptureRecordUnion_RecordType `protobuf:"varint,2,opt,name=record_type,json=recordType,enum=netbrane.CaptureRecordUnion_RecordType" json:"record_type,omitempty"`
	CaptureSpec       *common.CaptureSpec           `protobuf:"bytes,3,opt,name=capture_spec,json=captureSpec" json:"capture_spec,omitempty"`
	FlowRecord        *FlowRecord                   `protobuf:"bytes,4,opt,name=flow_record,json=flowRecord" json:"flow_record,omitempty"`
	BgpUpdateRecord   *bgp.BGPUpdate                `protobuf:"bytes,5,opt,name=bgp_update_record,json=bgpUpdateRecord" json:"bgp_update_record,omitempty"`
	DnsRecord         *DNSRecord                    `protobuf:"bytes,6,opt,name=dns_record,json=dnsRecord" json:"dns_record,omitempty"`
	ProbeRecord       *proddle.Probe                `protobuf:"bytes,7,opt,name=probe_record,json=probeRecord" json:"probe_record,omitempty"`
	ProbeResultRecord *proddle.ProbeResult          `protobuf:"bytes,8,opt,name=probe_result_record,json=probeResultRecord" json:"probe_result_record,omitempty"`
}

func (m *CaptureRecordUnion) Reset()                    { *m = CaptureRecordUnion{} }
func (m *CaptureRecordUnion) String() string            { return proto.CompactTextString(m) }
func (*CaptureRecordUnion) ProtoMessage()               {}
func (*CaptureRecordUnion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CaptureRecordUnion) GetTimestampSeconds() int64 {
	if m != nil {
		return m.TimestampSeconds
	}
	return 0
}

func (m *CaptureRecordUnion) GetRecordType() CaptureRecordUnion_RecordType {
	if m != nil {
		return m.RecordType
	}
	return CaptureRecordUnion_CAPTURE_SPEC
}

func (m *CaptureRecordUnion) GetCaptureSpec() *common.CaptureSpec {
	if m != nil {
		return m.CaptureSpec
	}
	return nil
}

func (m *CaptureRecordUnion) GetFlowRecord() *FlowRecord {
	if m != nil {
		return m.FlowRecord
	}
	return nil
}

func (m *CaptureRecordUnion) GetBgpUpdateRecord() *bgp.BGPUpdate {
	if m != nil {
		return m.BgpUpdateRecord
	}
	return nil
}

func (m *CaptureRecordUnion) GetDnsRecord() *DNSRecord {
	if m != nil {
		return m.DnsRecord
	}
	return nil
}

func (m *CaptureRecordUnion) GetProbeRecord() *proddle.Probe {
	if m != nil {
		return m.ProbeRecord
	}
	return nil
}

func (m *CaptureRecordUnion) GetProbeResultRecord() *proddle.ProbeResult {
	if m != nil {
		return m.ProbeResultRecord
	}
	return nil
}

func init() {
	proto.RegisterType((*PacketData)(nil), "netbrane.PacketData")
	proto.RegisterType((*IPFlow)(nil), "netbrane.IPFlow")
	proto.RegisterType((*FlowRecord)(nil), "netbrane.FlowRecord")
	proto.RegisterType((*DNSRecord)(nil), "netbrane.DNSRecord")
	proto.RegisterType((*CaptureRecordUnion)(nil), "netbrane.CaptureRecordUnion")
	proto.RegisterEnum("netbrane.FlowRecord_L2Proto", FlowRecord_L2Proto_name, FlowRecord_L2Proto_value)
	proto.RegisterEnum("netbrane.CaptureRecordUnion_RecordType", CaptureRecordUnion_RecordType_name, CaptureRecordUnion_RecordType_value)
}

func init() {
	proto.RegisterFile("github.com/CSUNetSec/netsec-protobufs/netbrane/netbrane.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1279 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x56, 0x5d, 0x73, 0xdb, 0x54,
	0x13, 0x7e, 0x1d, 0x7f, 0xaf, 0x1c, 0xc7, 0x39, 0x49, 0x5b, 0xbd, 0x19, 0x18, 0x8a, 0x2f, 0x68,
	0x86, 0x0f, 0x17, 0x9c, 0x00, 0x03, 0xa5, 0xc3, 0xa4, 0xb1, 0x4b, 0x3b, 0x04, 0xc7, 0x73, 0x1c,
	0x4f, 0x2f, 0x35, 0xb2, 0x74, 0xec, 0x6a, 0x6a, 0x4b, 0x42, 0x47, 0x6e, 0xc7, 0xdc, 0x71, 0xc3,
	0x1f, 0xe0, 0x07, 0x72, 0xc9, 0x4f, 0xe0, 0x96, 0xdd, 0x3d, 0x92, 0xed, 0x40, 0x69, 0x72, 0x91,
	0xc9, 0xee, 0xb3, 0xcf, 0x9e, 0x8f, 0x3d, 0xcf, 0xae, 0x05, 0x8f, 0x67, 0x41, 0xfa, 0x72, 0x39,
	0xe9, 0x78, 0xd1, 0xe2, 0xe1, 0xf9, 0x68, 0x3c, 0x50, 0xe9, 0x48, 0x79, 0x0f, 0x43, 0x95, 0x6a,
	0xe5, 0x7d, 0x16, 0x27, 0x51, 0x1a, 0x4d, 0x96, 0x53, 0x4d, 0xc0, 0x24, 0x71, 0x43, 0xb5, 0x36,
	0x3a, 0x1c, 0x13, 0xb5, 0xdc, 0x3f, 0xfa, 0xe6, 0x76, 0x0b, 0x61, 0x78, 0x11, 0x85, 0xd9, 0x3f,
	0xb3, 0xc8, 0xd1, 0x77, 0xb7, 0x4b, 0x65, 0xcb, 0x8b, 0xe6, 0x0f, 0x27, 0xb3, 0x98, 0xfe, 0xb2,
	0xec, 0x47, 0xb7, 0xce, 0xf6, 0xfd, 0xb9, 0xca, 0xff, 0x9b, 0xe4, 0xf6, 0x1f, 0x3b, 0x00, 0x43,
	0xd7, 0x7b, 0xa5, 0xd2, 0x9e, 0x9b, 0xba, 0xe2, 0x04, 0xee, 0x86, 0x6e, 0x18, 0x69, 0x47, 0x07,
	0xa1, 0xa7, 0x9c, 0xe9, 0x3c, 0x7a, 0xe3, 0xe8, 0xd4, 0x4d, 0x52, 0xbb, 0x70, 0xbf, 0x70, 0x5c,
	0x92, 0x07, 0x1c, 0x1d, 0x51, 0xf0, 0x29, 0xc6, 0x46, 0x14, 0x12, 0x1f, 0x80, 0x15, 0xf3, 0x12,
	0x98, 0xf5, 0x8b, 0xb2, 0x77, 0x90, 0xb9, 0x2b, 0xc1, 0x40, 0x23, 0x44, 0xc4, 0x01, 0x94, 0x83,
	0xd8, 0x09, 0x7c, 0xbb, 0xc8, 0xa1, 0x52, 0x10, 0x3f, 0xf7, 0x29, 0x2b, 0xd0, 0xce, 0x34, 0x71,
	0x67, 0x0b, 0x15, 0xa6, 0x76, 0x09, 0x43, 0x35, 0x09, 0x81, 0x7e, 0x9a, 0x21, 0x44, 0x78, 0x13,
	0x84, 0x3e, 0x9d, 0x80, 0x96, 0x2d, 0x23, 0xa1, 0x2c, 0xc1, 0x40, 0xbc, 0xec, 0x11, 0xd4, 0xb4,
	0xfa, 0x79, 0xa9, 0xf0, 0x30, 0x76, 0x85, 0x57, 0x5e, 0xfb, 0xa2, 0x05, 0x45, 0xdc, 0xdf, 0xae,
	0x32, 0x4c, 0x26, 0x21, 0x7a, 0x15, 0xda, 0x35, 0xde, 0x87, 0x4c, 0x42, 0xa6, 0x41, 0x68, 0xd7,
	0x0d, 0x82, 0xa6, 0x38, 0x84, 0x72, 0xa2, 0xb4, 0x4a, 0x6d, 0x60, 0xcc, 0x38, 0xe2, 0x7d, 0x80,
	0x28, 0x4e, 0x83, 0x28, 0xd4, 0xce, 0xfc, 0xc4, 0xb6, 0x38, 0x54, 0xcf, 0x90, 0x8b, 0x93, 0x6b,
	0xe1, 0x53, 0xbb, 0x71, 0x3d, 0x7c, 0xda, 0xfe, 0xbd, 0x02, 0x95, 0xe7, 0x43, 0xaa, 0x96, 0xe8,
	0x42, 0xd5, 0xf5, 0x7d, 0x5c, 0x54, 0x73, 0x39, 0xad, 0xae, 0xdd, 0xc9, 0x74, 0xf0, 0x7c, 0x78,
	0x66, 0x02, 0x2f, 0x12, 0x37, 0x8e, 0x55, 0x22, 0x73, 0xa2, 0xf8, 0x14, 0x4a, 0x0b, 0x57, 0xbf,
	0xe2, 0xaa, 0xbe, 0x2b, 0x81, 0x59, 0x42, 0x40, 0x29, 0x8e, 0xf0, 0xb5, 0x8a, 0x5c, 0x2c, 0xb6,
	0xe9, 0x9a, 0x69, 0xa4, 0xb9, 0xc0, 0x65, 0x49, 0x26, 0x23, 0xe9, 0x3c, 0xab, 0x28, 0x99, 0x74,
	0xf1, 0xc9, 0x2a, 0x55, 0x9a, 0xeb, 0x58, 0x94, 0xc6, 0x11, 0x9f, 0xc0, 0x3e, 0x2e, 0x3e, 0x0f,
	0x3c, 0x97, 0x2e, 0xe3, 0x18, 0x46, 0x95, 0x19, 0xad, 0xad, 0xc0, 0x13, 0x26, 0xdb, 0x50, 0x35,
	0x4f, 0xae, 0xb9, 0xc6, 0x45, 0x99, 0xbb, 0x74, 0xa8, 0x79, 0x84, 0x77, 0xa6, 0x42, 0xef, 0x48,
	0xb6, 0x09, 0x4b, 0x57, 0xb1, 0xe2, 0x42, 0xe3, 0x41, 0xc9, 0x26, 0xcc, 0x8b, 0x7c, 0xc5, 0x15,
	0x46, 0x8c, 0x6c, 0xd1, 0x84, 0x1d, 0xd4, 0x4d, 0x83, 0x11, 0xb4, 0xc4, 0x31, 0xec, 0x25, 0x2a,
	0xc5, 0x86, 0xd3, 0x8b, 0x40, 0x6b, 0x2a, 0xb1, 0xbd, 0xcb, 0xbb, 0xfd, 0x13, 0x16, 0xf7, 0xa0,
	0xfa, 0x7a, 0xee, 0x86, 0x24, 0xbb, 0x26, 0xa7, 0x57, 0xc8, 0x45, 0xe1, 0xe1, 0x7b, 0xe9, 0x68,
	0x99, 0xa0, 0xbc, 0x17, 0xae, 0x67, 0xef, 0xdd, 0x2f, 0x1e, 0x37, 0x64, 0xdd, 0x20, 0x3f, 0xb9,
	0x9e, 0x78, 0x00, 0x7b, 0xbe, 0xd2, 0x69, 0x10, 0x9a, 0x4b, 0x13, 0xa7, 0xc5, 0x9c, 0xe6, 0x16,
	0x4c, 0xc4, 0xcf, 0xe1, 0x30, 0x7e, 0xb9, 0xd2, 0x58, 0x84, 0xb9, 0x43, 0x85, 0x76, 0xc2, 0xe5,
	0x62, 0xa2, 0x12, 0x7b, 0x1f, 0xd9, 0x65, 0x29, 0xf2, 0xd8, 0x10, 0x43, 0x03, 0x8e, 0xd0, 0x91,
	0x66, 0x89, 0x72, 0x5e, 0xa9, 0x95, 0x2d, 0x58, 0x98, 0x15, 0x74, 0x7f, 0x54, 0x2b, 0xf1, 0x18,
	0x76, 0x83, 0x30, 0x54, 0x89, 0x93, 0xcb, 0xe3, 0xe0, 0x86, 0xd7, 0x6e, 0x30, 0x3d, 0x03, 0xc5,
	0xd7, 0x00, 0x26, 0x9d, 0xdf, 0xfe, 0xf0, 0x86, 0xdc, 0x3a, 0x73, 0xe9, 0x58, 0xe2, 0x7b, 0x68,
	0x66, 0x89, 0xd9, 0x68, 0xb1, 0xef, 0xdc, 0x90, 0x6c, 0xce, 0x39, 0xcc, 0xe8, 0xb8, 0x73, 0x23,
	0x6b, 0x7d, 0x5f, 0x79, 0x51, 0x62, 0xdf, 0xc5, 0xbb, 0x5b, 0xdd, 0xc3, 0xce, 0x7a, 0x4a, 0x6e,
	0x66, 0x8b, 0xcc, 0x86, 0x44, 0x8f, 0x88, 0xed, 0xdf, 0x4a, 0x00, 0xd4, 0x13, 0x92, 0x3c, 0x5f,
	0x7c, 0x04, 0x7b, 0x9e, 0x1b, 0xa7, 0x4b, 0xac, 0x8e, 0x8e, 0x95, 0x47, 0x8f, 0x56, 0xe0, 0x47,
	0xdb, 0xcd, 0xe0, 0x11, 0xa2, 0xf8, 0x76, 0xa8, 0xc8, 0x34, 0x58, 0xe0, 0x3b, 0xb8, 0x8b, 0xd8,
	0xc1, 0xf9, 0x16, 0x85, 0xbe, 0xe6, 0xd6, 0x40, 0x45, 0xae, 0x03, 0x23, 0x83, 0x8b, 0x0f, 0xa1,
	0xb1, 0x21, 0xa3, 0x50, 0xcc, 0xf4, 0xb1, 0xd6, 0xd8, 0x40, 0xd3, 0x8c, 0xf1, 0x97, 0x89, 0x79,
	0xe9, 0xa5, 0xe9, 0x91, 0xa2, 0x84, 0x1c, 0x1a, 0x53, 0x69, 0x6b, 0xf3, 0xae, 0x29, 0x0f, 0xf7,
	0x4b, 0xb3, 0xfb, 0xde, 0xe6, 0x72, 0x9b, 0x0b, 0x74, 0x2e, 0xba, 0x5c, 0x13, 0x59, 0x9d, 0x1b,
	0x43, 0xfc, 0x1f, 0x13, 0x4f, 0xb2, 0xc4, 0x0a, 0x5f, 0xa5, 0x3a, 0x3f, 0xd9, 0x84, 0x4e, 0xb3,
	0x50, 0x35, 0x0b, 0x9d, 0x9a, 0xd0, 0x31, 0x54, 0x8c, 0x12, 0xb9, 0x87, 0xac, 0x6e, 0x6b, 0xb3,
	0x99, 0x99, 0x21, 0x32, 0x8b, 0xe3, 0x2c, 0xb1, 0xb6, 0xf4, 0xc8, 0xbd, 0xf5, 0x36, 0xfa, 0x36,
	0x49, 0x3c, 0x82, 0x23, 0xa3, 0x51, 0x27, 0x9a, 0x3a, 0xee, 0x0c, 0xc5, 0x37, 0x73, 0x53, 0xe5,
	0xf3, 0x98, 0xd7, 0xdc, 0x8a, 0x45, 0x79, 0xcf, 0x30, 0x2e, 0xa7, 0x67, 0xeb, 0x38, 0x2d, 0x44,
	0x83, 0x48, 0x4c, 0x96, 0xe6, 0xa9, 0xb7, 0x2a, 0x66, 0x99, 0xda, 0x9b, 0x48, 0x6f, 0x5d, 0xb7,
	0xf6, 0x03, 0xa8, 0x66, 0x25, 0x11, 0x16, 0x99, 0xce, 0xe0, 0x72, 0xd0, 0x6f, 0xfd, 0x4f, 0xec,
	0x81, 0x85, 0x4e, 0xff, 0xea, 0x59, 0x5f, 0x0e, 0xfa, 0x57, 0xad, 0x42, 0xfb, 0xaf, 0x02, 0xd4,
	0x7b, 0x83, 0x51, 0xa6, 0x83, 0x33, 0x6a, 0x6f, 0x1c, 0xe1, 0x74, 0xe6, 0x99, 0xf3, 0x32, 0xd2,
	0xe9, 0x8d, 0x93, 0xb2, 0xb9, 0x49, 0x78, 0x86, 0x7c, 0x6a, 0x06, 0x1f, 0x47, 0xb1, 0x56, 0xc9,
	0x6b, 0x6c, 0xc6, 0x9b, 0xc6, 0x66, 0x1d, 0xb9, 0x23, 0xa6, 0x8a, 0x8f, 0xa1, 0x18, 0xc4, 0xa4,
	0x92, 0xe2, 0x3b, 0x33, 0x88, 0x44, 0xf3, 0xd2, 0x0b, 0xdd, 0x85, 0x42, 0xc5, 0x14, 0x8f, 0xeb,
	0xd2, 0x38, 0x84, 0xe2, 0x51, 0x92, 0x15, 0x2b, 0x05, 0x51, 0x76, 0xc4, 0x5d, 0xa8, 0xe0, 0x26,
	0x28, 0x56, 0xd6, 0x41, 0x4d, 0x66, 0x5e, 0xfb, 0xcf, 0x12, 0x88, 0x73, 0xa3, 0x6e, 0x73, 0xfb,
	0x71, 0x48, 0x8f, 0xf4, 0x56, 0x89, 0x17, 0xfe, 0x43, 0xe2, 0xcf, 0xc0, 0x4a, 0x38, 0xd7, 0xe1,
	0x69, 0xba, 0xc3, 0x0a, 0x7d, 0xb0, 0x51, 0xc1, 0xbf, 0xd7, 0xef, 0x18, 0xfb, 0x0a, 0xe9, 0x12,
	0x92, 0xb5, 0x2d, 0xbe, 0x82, 0xc6, 0x76, 0x07, 0x72, 0xb3, 0x58, 0xdd, 0x83, 0xbc, 0x0c, 0xe7,
	0x9b, 0x36, 0x94, 0xd6, 0x56, 0x4f, 0x8a, 0x2f, 0xc1, 0xe2, 0xaf, 0x04, 0xb3, 0x14, 0x77, 0xd0,
	0xb5, 0x01, 0xb0, 0xe9, 0x11, 0x09, 0xd3, 0x4d, 0xc3, 0x7f, 0x0b, 0xfb, 0xf8, 0x05, 0xe3, 0x2c,
	0x63, 0x1f, 0x15, 0x96, 0x27, 0x97, 0x39, 0xb9, 0xd9, 0xa1, 0x6f, 0x9b, 0x27, 0x3f, 0x0c, 0xc7,
	0x1c, 0x94, 0x7b, 0xe8, 0x66, 0xa6, 0xc9, 0xed, 0x9a, 0x17, 0xce, 0x92, 0x2a, 0xd9, 0x41, 0xd7,
	0x3b, 0xae, 0xd5, 0xc4, 0x8f, 0x9b, 0xe5, 0x7c, 0x81, 0x83, 0x2a, 0x89, 0x26, 0xeb, 0xad, 0xaa,
	0xd9, 0x56, 0xf9, 0xd7, 0xd0, 0x90, 0x82, 0x38, 0xa2, 0xf8, 0x9f, 0x49, 0xe9, 0xc1, 0x41, 0x9e,
	0xa2, 0x97, 0xf3, 0x34, 0xcf, 0xac, 0x65, 0x37, 0xbc, 0x9e, 0xc9, 0x14, 0xb9, 0x1f, 0x6f, 0x39,
	0x4c, 0x6f, 0xff, 0x5a, 0x00, 0xd8, 0x94, 0x1c, 0x7f, 0x7a, 0x1b, 0xe7, 0x67, 0xc3, 0xab, 0xb1,
	0xec, 0x3b, 0xa3, 0x61, 0xff, 0xdc, 0x74, 0xc4, 0xd3, 0x8b, 0xcb, 0x17, 0x8e, 0xec, 0x9f, 0x5f,
	0xca, 0x5e, 0xab, 0x20, 0xee, 0xc0, 0x3e, 0x5e, 0xde, 0x19, 0x0f, 0x7b, 0x67, 0x57, 0xfd, 0x1c,
	0xde, 0xc1, 0x5f, 0x42, 0xc0, 0x9b, 0xe5, 0x7e, 0x91, 0x56, 0x1a, 0xca, 0xcb, 0x27, 0x6b, 0x46,
	0x09, 0x7f, 0x5e, 0x0e, 0x72, 0x64, 0x34, 0xbe, 0xb8, 0xca, 0x03, 0xe5, 0x49, 0x85, 0x67, 0xcd,
	0xc9, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x1c, 0x3e, 0xdf, 0x49, 0xec, 0x0a, 0x00, 0x00,
}
