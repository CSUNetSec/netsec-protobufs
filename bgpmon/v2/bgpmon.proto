syntax = "proto3";

import "github.com/CSUNetSec/netsec-protobufs/common/common.proto";
import "github.com/CSUNetSec/netsec-protobufs/protocol/bgp/bgp.proto";

package bgpmonv2;

service Bgpmond {
	rpc CloseSession(CloseSessionRequest) returns (Empty) {}
	rpc ListOpenSessions(Empty) returns (ListOpenSessionsReply) {}
	rpc ListAvailableSessions(Empty) returns (ListAvailableSessionsReply) {}
	rpc OpenSession(OpenSessionRequest) returns (OpenSessionReply) {}
	rpc Write(stream WriteRequest) returns (WriteReply) {}
	rpc Get(GetRequest) returns (stream GetReply) {}
	rpc GetSessionInfo(SessionInfoRequest) returns (SessionInfoReply) {}

        rpc RunModule(RunModuleRequest) returns (RunModuleReply) {}
        rpc CloseModule(CloseModuleRequest) returns (Empty) {}
        rpc ListAvailableModules(Empty) returns (ListAvailableModulesReply) {}
        rpc ListOpenModules(Empty) returns (ListOpenModulesReply) {}
}

message Empty {
}

/*
 * Module Messages
 */

message RunModuleRequest {
    // maximal field value = 3

    string type = 1;
    string id = 2;
    string args = 3;
}

message RunModuleReply {
    // maximal field value = 1

    string id = 1;
}

message CloseModuleRequest {
    // maximal field value = 1

    string id = 1;
}

message ModuleInfo {
    // maximal field value = 3

    string type = 1;
    string desc = 2;
    string opts = 3;
}

message ListAvailableModulesReply {
    // maximal field value = 1

    repeated ModuleInfo available_modules = 1;
}

message OpenModuleInfo {
    // maximal field value = 3

    string type = 1;
    string id = 2;
    string status = 3;
}

message ListOpenModulesReply {
    // maximal field value = 1

    repeated OpenModuleInfo open_modules = 1;
}

/*
 * Session Messages
 */

message SessionType {
	//maximal field value = 3

	string name = 1;
	string type = 2;
	string desc = 3;
}

message SessionInfoRequest {
    //maximal field value = 1

    string session_id = 1;
}

message SessionInfoReply {
    //maximal field value = 3

    SessionType type = 1;
    string session_id = 2;
    uint32 workers = 3;
}

message ListAvailableSessionsReply {
	//maximal field value = 1

	repeated SessionType available_sessions = 1;
}

/*
 * Session Command Messages 
 */
message CloseSessionRequest {
	//maximal field value = 1

	string session_id = 1;
}

message ListOpenSessionsReply {
	//maximal field value = 1

	repeated string session_id = 1;
}

message OpenSessionRequest {
	//maximal field value = 3

	string session_name = 1;
	string session_id = 2;
	uint32 workers = 3;
}

message OpenSessionReply {
	//maximal field value = 1

	string session_id = 1;
}

/*
 * Write Messages
 */
message WriteRequest {
	//maximal field value = 3

	enum Type {
		BGP_CAPTURE = 0;
	}

	Type type = 1;
	string session_id = 2;
	BGPCapture bgp_capture = 3;
}

message WriteReply {
	uint64 totalMessages = 1;
	uint64 startTime = 2;
	uint64 endTime = 3;
	uint32 numWorkers = 4;
	string error = 5;
}

/*
 * Get Messages
 */
message GetRequest {
	//maximal field value = 6

	enum Type {
		CAPTURE = 0;
		PREFIX = 1;
		ASPATH = 2;
	}
	Type type = 1;
	string session_id = 2;
	repeated Filter filters = 3;
	string collector_name = 4;
	uint64 start_timestamp = 5;
        uint64 end_timestamp = 6;
}

message  Filter {
	//maximal field value = 4
	enum FilterType {
		ORIGIN_AS = 0;
		PREFIXEXACT = 1;
		PREFIXINCLUDED = 2;
	}
	FilterType type = 1;
	uint32 origin_as = 2;
	string advertised_prefix = 3;
	string withdrawn_prefix = 4;
}

//GetReply carries chunks of a PBStream byte array.
//If it is incomplete then the client should read all
//the following messages until the incomplete flag is not set
//and then try to unmarshal the message. Also the Type once an
//incomplete stream starts has to remain the same accros all subsequent
//messages
message GetReply {
	//maximal field value = 4
	GetRequest.Type type = 1;
	string error = 2;
	bool incomplete = 3;
	repeated bytes chunk = 4;
}

// a message of Capture type to facilitate the represtation of a
// BGP Update from multuple sources (live/mrt etc) to bgpmon 
// and other systems. the inner actual update is defined in protocol/bgp
message BGPCapture {
	//maximal field value = 8

	uint32 timestamp = 1;
	uint32 peer_as = 2;
	uint32 local_as = 3;
	uint32 interface_index = 4;
	uint32 address_family = 5;
	common.IPAddressWrapper peer_IP = 6;
	common.IPAddressWrapper local_IP = 7;
	bgp.BGPUpdate update = 8;
}

