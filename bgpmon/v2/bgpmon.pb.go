// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/CSUNetSec/netsec-protobufs/bgpmon/v2/bgpmon.proto

/*
Package bgpmonv2 is a generated protocol buffer package.

It is generated from these files:
	github.com/CSUNetSec/netsec-protobufs/bgpmon/v2/bgpmon.proto

It has these top-level messages:
	Empty
	SessionType
	SessionInfoRequest
	SessionInfoReply
	ListAvailableSessionsReply
	CloseSessionRequest
	ListOpenSessionsReply
	OpenSessionRequest
	OpenSessionReply
	WriteRequest
	WriteReply
	GetRequest
	GetReply
	BGPCapture
*/
package bgpmonv2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "github.com/CSUNetSec/netsec-protobufs/common"
import bgp "github.com/CSUNetSec/netsec-protobufs/protocol/bgp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type WriteRequest_Type int32

const (
	WriteRequest_BGP_CAPTURE WriteRequest_Type = 0
)

var WriteRequest_Type_name = map[int32]string{
	0: "BGP_CAPTURE",
}
var WriteRequest_Type_value = map[string]int32{
	"BGP_CAPTURE": 0,
}

func (x WriteRequest_Type) String() string {
	return proto.EnumName(WriteRequest_Type_name, int32(x))
}
func (WriteRequest_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

type GetRequest_Type int32

const (
	GetRequest_BGP_CAPTURE GetRequest_Type = 0
)

var GetRequest_Type_name = map[int32]string{
	0: "BGP_CAPTURE",
}
var GetRequest_Type_value = map[string]int32{
	"BGP_CAPTURE": 0,
}

func (x GetRequest_Type) String() string {
	return proto.EnumName(GetRequest_Type_name, int32(x))
}
func (GetRequest_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{11, 0} }

type GetReply_Type int32

const (
	GetReply_BGP_CAPTURE GetReply_Type = 0
)

var GetReply_Type_name = map[int32]string{
	0: "BGP_CAPTURE",
}
var GetReply_Type_value = map[string]int32{
	"BGP_CAPTURE": 0,
}

func (x GetReply_Type) String() string {
	return proto.EnumName(GetReply_Type_name, int32(x))
}
func (GetReply_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type SessionType struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Desc string `protobuf:"bytes,3,opt,name=desc" json:"desc,omitempty"`
}

func (m *SessionType) Reset()                    { *m = SessionType{} }
func (m *SessionType) String() string            { return proto.CompactTextString(m) }
func (*SessionType) ProtoMessage()               {}
func (*SessionType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SessionType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SessionType) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SessionType) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

type SessionInfoRequest struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *SessionInfoRequest) Reset()                    { *m = SessionInfoRequest{} }
func (m *SessionInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionInfoRequest) ProtoMessage()               {}
func (*SessionInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SessionInfoRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

type SessionInfoReply struct {
	Type      *SessionType `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	SessionId string       `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	Workers   uint32       `protobuf:"varint,3,opt,name=workers" json:"workers,omitempty"`
}

func (m *SessionInfoReply) Reset()                    { *m = SessionInfoReply{} }
func (m *SessionInfoReply) String() string            { return proto.CompactTextString(m) }
func (*SessionInfoReply) ProtoMessage()               {}
func (*SessionInfoReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SessionInfoReply) GetType() *SessionType {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *SessionInfoReply) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *SessionInfoReply) GetWorkers() uint32 {
	if m != nil {
		return m.Workers
	}
	return 0
}

type ListAvailableSessionsReply struct {
	AvailableSessions []*SessionType `protobuf:"bytes,1,rep,name=available_sessions,json=availableSessions" json:"available_sessions,omitempty"`
}

func (m *ListAvailableSessionsReply) Reset()                    { *m = ListAvailableSessionsReply{} }
func (m *ListAvailableSessionsReply) String() string            { return proto.CompactTextString(m) }
func (*ListAvailableSessionsReply) ProtoMessage()               {}
func (*ListAvailableSessionsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ListAvailableSessionsReply) GetAvailableSessions() []*SessionType {
	if m != nil {
		return m.AvailableSessions
	}
	return nil
}

//
// Session Command Messages
type CloseSessionRequest struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *CloseSessionRequest) Reset()                    { *m = CloseSessionRequest{} }
func (m *CloseSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*CloseSessionRequest) ProtoMessage()               {}
func (*CloseSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CloseSessionRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

type ListOpenSessionsReply struct {
	SessionId []string `protobuf:"bytes,1,rep,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *ListOpenSessionsReply) Reset()                    { *m = ListOpenSessionsReply{} }
func (m *ListOpenSessionsReply) String() string            { return proto.CompactTextString(m) }
func (*ListOpenSessionsReply) ProtoMessage()               {}
func (*ListOpenSessionsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ListOpenSessionsReply) GetSessionId() []string {
	if m != nil {
		return m.SessionId
	}
	return nil
}

type OpenSessionRequest struct {
	SessionName string `protobuf:"bytes,1,opt,name=session_name,json=sessionName" json:"session_name,omitempty"`
	SessionId   string `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	Workers     uint32 `protobuf:"varint,3,opt,name=workers" json:"workers,omitempty"`
}

func (m *OpenSessionRequest) Reset()                    { *m = OpenSessionRequest{} }
func (m *OpenSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenSessionRequest) ProtoMessage()               {}
func (*OpenSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *OpenSessionRequest) GetSessionName() string {
	if m != nil {
		return m.SessionName
	}
	return ""
}

func (m *OpenSessionRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *OpenSessionRequest) GetWorkers() uint32 {
	if m != nil {
		return m.Workers
	}
	return 0
}

type OpenSessionReply struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *OpenSessionReply) Reset()                    { *m = OpenSessionReply{} }
func (m *OpenSessionReply) String() string            { return proto.CompactTextString(m) }
func (*OpenSessionReply) ProtoMessage()               {}
func (*OpenSessionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *OpenSessionReply) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

//
// Write Messages
type WriteRequest struct {
	Type       WriteRequest_Type `protobuf:"varint,1,opt,name=type,enum=bgpmonv2.WriteRequest_Type" json:"type,omitempty"`
	SessionId  string            `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	BgpCapture *BGPCapture       `protobuf:"bytes,3,opt,name=bgp_capture,json=bgpCapture" json:"bgp_capture,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *WriteRequest) GetType() WriteRequest_Type {
	if m != nil {
		return m.Type
	}
	return WriteRequest_BGP_CAPTURE
}

func (m *WriteRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *WriteRequest) GetBgpCapture() *BGPCapture {
	if m != nil {
		return m.BgpCapture
	}
	return nil
}

type WriteReply struct {
	TotalMessages uint64 `protobuf:"varint,1,opt,name=totalMessages" json:"totalMessages,omitempty"`
	StartTime     uint64 `protobuf:"varint,2,opt,name=startTime" json:"startTime,omitempty"`
	EndTime       uint64 `protobuf:"varint,3,opt,name=endTime" json:"endTime,omitempty"`
	NumWorkers    uint32 `protobuf:"varint,4,opt,name=numWorkers" json:"numWorkers,omitempty"`
	Error         string `protobuf:"bytes,5,opt,name=error" json:"error,omitempty"`
}

func (m *WriteReply) Reset()                    { *m = WriteReply{} }
func (m *WriteReply) String() string            { return proto.CompactTextString(m) }
func (*WriteReply) ProtoMessage()               {}
func (*WriteReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *WriteReply) GetTotalMessages() uint64 {
	if m != nil {
		return m.TotalMessages
	}
	return 0
}

func (m *WriteReply) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *WriteReply) GetEndTime() uint64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *WriteReply) GetNumWorkers() uint32 {
	if m != nil {
		return m.NumWorkers
	}
	return 0
}

func (m *WriteReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

//
// Get Messages
type GetRequest struct {
	Type           GetRequest_Type `protobuf:"varint,1,opt,name=type,enum=bgpmonv2.GetRequest_Type" json:"type,omitempty"`
	SessionId      string          `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	StartTimestamp string          `protobuf:"bytes,3,opt,name=start_timestamp,json=startTimestamp" json:"start_timestamp,omitempty"`
	EndTimestamp   string          `protobuf:"bytes,4,opt,name=end_timestamp,json=endTimestamp" json:"end_timestamp,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetRequest) GetType() GetRequest_Type {
	if m != nil {
		return m.Type
	}
	return GetRequest_BGP_CAPTURE
}

func (m *GetRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *GetRequest) GetStartTimestamp() string {
	if m != nil {
		return m.StartTimestamp
	}
	return ""
}

func (m *GetRequest) GetEndTimestamp() string {
	if m != nil {
		return m.EndTimestamp
	}
	return ""
}

type GetReply struct {
	Type     GetReply_Type `protobuf:"varint,1,opt,name=type,enum=bgpmonv2.GetReply_Type" json:"type,omitempty"`
	Captures []*BGPCapture `protobuf:"bytes,2,rep,name=captures" json:"captures,omitempty"`
	Error    string        `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *GetReply) Reset()                    { *m = GetReply{} }
func (m *GetReply) String() string            { return proto.CompactTextString(m) }
func (*GetReply) ProtoMessage()               {}
func (*GetReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GetReply) GetType() GetReply_Type {
	if m != nil {
		return m.Type
	}
	return GetReply_BGP_CAPTURE
}

func (m *GetReply) GetCaptures() []*BGPCapture {
	if m != nil {
		return m.Captures
	}
	return nil
}

func (m *GetReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// a message of Capture type to facilitate the represtation of a
// BGP Update from multuple sources (live/mrt etc) to bgpmon
// and other systems. the inner actual update is defined in protocol/bgp
type BGPCapture struct {
	Timestamp      uint32                   `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	PeerAs         uint32                   `protobuf:"varint,2,opt,name=peer_as,json=peerAs" json:"peer_as,omitempty"`
	LocalAs        uint32                   `protobuf:"varint,3,opt,name=local_as,json=localAs" json:"local_as,omitempty"`
	InterfaceIndex uint32                   `protobuf:"varint,4,opt,name=interface_index,json=interfaceIndex" json:"interface_index,omitempty"`
	AddressFamily  uint32                   `protobuf:"varint,5,opt,name=address_family,json=addressFamily" json:"address_family,omitempty"`
	PeerIp         *common.IPAddressWrapper `protobuf:"bytes,6,opt,name=peer_ip,json=peerIp" json:"peer_ip,omitempty"`
	LocalIp        *common.IPAddressWrapper `protobuf:"bytes,7,opt,name=local_ip,json=localIp" json:"local_ip,omitempty"`
	Update         *bgp.BGPUpdate           `protobuf:"bytes,8,opt,name=update" json:"update,omitempty"`
}

func (m *BGPCapture) Reset()                    { *m = BGPCapture{} }
func (m *BGPCapture) String() string            { return proto.CompactTextString(m) }
func (*BGPCapture) ProtoMessage()               {}
func (*BGPCapture) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *BGPCapture) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *BGPCapture) GetPeerAs() uint32 {
	if m != nil {
		return m.PeerAs
	}
	return 0
}

func (m *BGPCapture) GetLocalAs() uint32 {
	if m != nil {
		return m.LocalAs
	}
	return 0
}

func (m *BGPCapture) GetInterfaceIndex() uint32 {
	if m != nil {
		return m.InterfaceIndex
	}
	return 0
}

func (m *BGPCapture) GetAddressFamily() uint32 {
	if m != nil {
		return m.AddressFamily
	}
	return 0
}

func (m *BGPCapture) GetPeerIp() *common.IPAddressWrapper {
	if m != nil {
		return m.PeerIp
	}
	return nil
}

func (m *BGPCapture) GetLocalIp() *common.IPAddressWrapper {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *BGPCapture) GetUpdate() *bgp.BGPUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "bgpmonv2.Empty")
	proto.RegisterType((*SessionType)(nil), "bgpmonv2.SessionType")
	proto.RegisterType((*SessionInfoRequest)(nil), "bgpmonv2.SessionInfoRequest")
	proto.RegisterType((*SessionInfoReply)(nil), "bgpmonv2.SessionInfoReply")
	proto.RegisterType((*ListAvailableSessionsReply)(nil), "bgpmonv2.ListAvailableSessionsReply")
	proto.RegisterType((*CloseSessionRequest)(nil), "bgpmonv2.CloseSessionRequest")
	proto.RegisterType((*ListOpenSessionsReply)(nil), "bgpmonv2.ListOpenSessionsReply")
	proto.RegisterType((*OpenSessionRequest)(nil), "bgpmonv2.OpenSessionRequest")
	proto.RegisterType((*OpenSessionReply)(nil), "bgpmonv2.OpenSessionReply")
	proto.RegisterType((*WriteRequest)(nil), "bgpmonv2.WriteRequest")
	proto.RegisterType((*WriteReply)(nil), "bgpmonv2.WriteReply")
	proto.RegisterType((*GetRequest)(nil), "bgpmonv2.GetRequest")
	proto.RegisterType((*GetReply)(nil), "bgpmonv2.GetReply")
	proto.RegisterType((*BGPCapture)(nil), "bgpmonv2.BGPCapture")
	proto.RegisterEnum("bgpmonv2.WriteRequest_Type", WriteRequest_Type_name, WriteRequest_Type_value)
	proto.RegisterEnum("bgpmonv2.GetRequest_Type", GetRequest_Type_name, GetRequest_Type_value)
	proto.RegisterEnum("bgpmonv2.GetReply_Type", GetReply_Type_name, GetReply_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Bgpmond service

type BgpmondClient interface {
	CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*Empty, error)
	ListOpenSessions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListOpenSessionsReply, error)
	ListAvailableSessions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListAvailableSessionsReply, error)
	OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...grpc.CallOption) (*OpenSessionReply, error)
	Write(ctx context.Context, opts ...grpc.CallOption) (Bgpmond_WriteClient, error)
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (Bgpmond_GetClient, error)
	GetSessionInfo(ctx context.Context, in *SessionInfoRequest, opts ...grpc.CallOption) (*SessionInfoReply, error)
}

type bgpmondClient struct {
	cc *grpc.ClientConn
}

func NewBgpmondClient(cc *grpc.ClientConn) BgpmondClient {
	return &bgpmondClient{cc}
}

func (c *bgpmondClient) CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/CloseSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) ListOpenSessions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListOpenSessionsReply, error) {
	out := new(ListOpenSessionsReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/ListOpenSessions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) ListAvailableSessions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListAvailableSessionsReply, error) {
	out := new(ListAvailableSessionsReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/ListAvailableSessions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...grpc.CallOption) (*OpenSessionReply, error) {
	out := new(OpenSessionReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/OpenSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) Write(ctx context.Context, opts ...grpc.CallOption) (Bgpmond_WriteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Bgpmond_serviceDesc.Streams[0], c.cc, "/bgpmonv2.Bgpmond/Write", opts...)
	if err != nil {
		return nil, err
	}
	x := &bgpmondWriteClient{stream}
	return x, nil
}

type Bgpmond_WriteClient interface {
	Send(*WriteRequest) error
	CloseAndRecv() (*WriteReply, error)
	grpc.ClientStream
}

type bgpmondWriteClient struct {
	grpc.ClientStream
}

func (x *bgpmondWriteClient) Send(m *WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *bgpmondWriteClient) CloseAndRecv() (*WriteReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bgpmondClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (Bgpmond_GetClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Bgpmond_serviceDesc.Streams[1], c.cc, "/bgpmonv2.Bgpmond/Get", opts...)
	if err != nil {
		return nil, err
	}
	x := &bgpmondGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Bgpmond_GetClient interface {
	Recv() (*GetReply, error)
	grpc.ClientStream
}

type bgpmondGetClient struct {
	grpc.ClientStream
}

func (x *bgpmondGetClient) Recv() (*GetReply, error) {
	m := new(GetReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bgpmondClient) GetSessionInfo(ctx context.Context, in *SessionInfoRequest, opts ...grpc.CallOption) (*SessionInfoReply, error) {
	out := new(SessionInfoReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/GetSessionInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Bgpmond service

type BgpmondServer interface {
	CloseSession(context.Context, *CloseSessionRequest) (*Empty, error)
	ListOpenSessions(context.Context, *Empty) (*ListOpenSessionsReply, error)
	ListAvailableSessions(context.Context, *Empty) (*ListAvailableSessionsReply, error)
	OpenSession(context.Context, *OpenSessionRequest) (*OpenSessionReply, error)
	Write(Bgpmond_WriteServer) error
	Get(*GetRequest, Bgpmond_GetServer) error
	GetSessionInfo(context.Context, *SessionInfoRequest) (*SessionInfoReply, error)
}

func RegisterBgpmondServer(s *grpc.Server, srv BgpmondServer) {
	s.RegisterService(&_Bgpmond_serviceDesc, srv)
}

func _Bgpmond_CloseSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).CloseSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/CloseSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).CloseSession(ctx, req.(*CloseSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_ListOpenSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).ListOpenSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/ListOpenSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).ListOpenSessions(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_ListAvailableSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).ListAvailableSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/ListAvailableSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).ListAvailableSessions(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_OpenSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).OpenSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/OpenSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).OpenSession(ctx, req.(*OpenSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_Write_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BgpmondServer).Write(&bgpmondWriteServer{stream})
}

type Bgpmond_WriteServer interface {
	SendAndClose(*WriteReply) error
	Recv() (*WriteRequest, error)
	grpc.ServerStream
}

type bgpmondWriteServer struct {
	grpc.ServerStream
}

func (x *bgpmondWriteServer) SendAndClose(m *WriteReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *bgpmondWriteServer) Recv() (*WriteRequest, error) {
	m := new(WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Bgpmond_Get_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BgpmondServer).Get(m, &bgpmondGetServer{stream})
}

type Bgpmond_GetServer interface {
	Send(*GetReply) error
	grpc.ServerStream
}

type bgpmondGetServer struct {
	grpc.ServerStream
}

func (x *bgpmondGetServer) Send(m *GetReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Bgpmond_GetSessionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).GetSessionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/GetSessionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).GetSessionInfo(ctx, req.(*SessionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Bgpmond_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bgpmonv2.Bgpmond",
	HandlerType: (*BgpmondServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CloseSession",
			Handler:    _Bgpmond_CloseSession_Handler,
		},
		{
			MethodName: "ListOpenSessions",
			Handler:    _Bgpmond_ListOpenSessions_Handler,
		},
		{
			MethodName: "ListAvailableSessions",
			Handler:    _Bgpmond_ListAvailableSessions_Handler,
		},
		{
			MethodName: "OpenSession",
			Handler:    _Bgpmond_OpenSession_Handler,
		},
		{
			MethodName: "GetSessionInfo",
			Handler:    _Bgpmond_GetSessionInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Write",
			Handler:       _Bgpmond_Write_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Get",
			Handler:       _Bgpmond_Get_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "github.com/CSUNetSec/netsec-protobufs/bgpmon/v2/bgpmon.proto",
}

func init() {
	proto.RegisterFile("github.com/CSUNetSec/netsec-protobufs/bgpmon/v2/bgpmon.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 892 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x8e, 0x9b, 0xb4, 0x49, 0x4f, 0x9a, 0xb4, 0x0c, 0x5d, 0xea, 0x35, 0xbb, 0xb0, 0x98, 0x05,
	0x16, 0xa1, 0x4d, 0x76, 0x53, 0x40, 0x5a, 0x89, 0x0b, 0xd2, 0xb2, 0x1b, 0x45, 0x5a, 0x4a, 0xe4,
	0xb6, 0xea, 0x65, 0x34, 0xb1, 0x4f, 0x83, 0x85, 0x7f, 0x06, 0xcf, 0xa4, 0x90, 0x37, 0xe1, 0x92,
	0x27, 0xe0, 0x11, 0x90, 0x78, 0x21, 0x9e, 0x01, 0xcd, 0x8f, 0x6b, 0x3b, 0x49, 0x45, 0xe1, 0xa2,
	0xea, 0xcc, 0x77, 0x7e, 0xe6, 0x3b, 0xdf, 0xf1, 0x9c, 0x09, 0x7c, 0x33, 0x0f, 0xc5, 0x8f, 0x8b,
	0x59, 0xcf, 0x4f, 0xe3, 0xfe, 0xe9, 0xf9, 0xe5, 0x19, 0x8a, 0x73, 0xf4, 0xfb, 0x09, 0x0a, 0x8e,
	0xfe, 0x73, 0x96, 0xa5, 0x22, 0x9d, 0x2d, 0xae, 0x79, 0x7f, 0x36, 0x67, 0x71, 0x9a, 0xf4, 0x6f,
	0x06, 0x66, 0xd5, 0x53, 0x26, 0xd2, 0xd2, 0xbb, 0x9b, 0x81, 0xf3, 0xea, 0x7e, 0x79, 0xfc, 0x34,
	0x96, 0x79, 0xf4, 0x3f, 0x9d, 0xc4, 0xb9, 0x27, 0x05, 0xb5, 0xf2, 0xd3, 0x48, 0x32, 0x90, 0x7f,
	0x3a, 0xda, 0x6d, 0xc2, 0xf6, 0xeb, 0x98, 0x89, 0xa5, 0x3b, 0x86, 0xf6, 0x39, 0x72, 0x1e, 0xa6,
	0xc9, 0xc5, 0x92, 0x21, 0x21, 0xd0, 0x48, 0x68, 0x8c, 0xb6, 0xf5, 0xc4, 0x7a, 0xb6, 0xeb, 0xa9,
	0xb5, 0xc4, 0xc4, 0x92, 0xa1, 0xbd, 0xa5, 0x31, 0x61, 0xfc, 0x02, 0xe4, 0xbe, 0x5d, 0xd7, 0x98,
	0x5c, 0xbb, 0xc7, 0x40, 0x4c, 0xaa, 0x71, 0x72, 0x9d, 0x7a, 0xf8, 0xf3, 0x02, 0xb9, 0x20, 0x8f,
	0x01, 0xb8, 0x46, 0xa7, 0x61, 0x60, 0xf2, 0xee, 0x1a, 0x64, 0x1c, 0xb8, 0x37, 0x70, 0x50, 0x09,
	0x62, 0xd1, 0x92, 0x7c, 0x6e, 0x0e, 0x94, 0xce, 0xed, 0xc1, 0x83, 0x5e, 0x2e, 0x57, 0xaf, 0xc4,
	0xd4, 0xf0, 0xa8, 0x66, 0xdf, 0x5a, 0xc9, 0x4e, 0x6c, 0x68, 0xfe, 0x92, 0x66, 0x3f, 0x61, 0xc6,
	0x15, 0xd3, 0x8e, 0x97, 0x6f, 0xdd, 0x19, 0x38, 0x6f, 0x43, 0x2e, 0x86, 0x37, 0x34, 0x8c, 0xe8,
	0x2c, 0x42, 0x93, 0x9a, 0x6b, 0x06, 0xdf, 0x01, 0xa1, 0xb9, 0x65, 0x6a, 0xd2, 0x71, 0xdb, 0x7a,
	0x52, 0xbf, 0x9b, 0xcf, 0x3b, 0x74, 0x35, 0x95, 0xfb, 0x25, 0xbc, 0x7b, 0x1a, 0xa5, 0x3c, 0x07,
	0xee, 0xa9, 0xc8, 0xd7, 0xf0, 0x40, 0x32, 0xfb, 0x81, 0x61, 0x52, 0x25, 0xb5, 0x1a, 0x57, 0xaf,
	0xc6, 0x31, 0x20, 0xa5, 0x98, 0xfc, 0xb0, 0x8f, 0x60, 0x2f, 0x0f, 0x2a, 0x35, 0xb6, 0x6d, 0xb0,
	0x33, 0xd9, 0xdf, 0xff, 0xad, 0xe1, 0x4b, 0x38, 0xa8, 0x9c, 0xb8, 0x89, 0xe4, 0x4a, 0x71, 0x7f,
	0x58, 0xb0, 0x77, 0x95, 0x85, 0x02, 0x73, 0x7e, 0xfd, 0x52, 0xaf, 0xbb, 0x83, 0xf7, 0x0b, 0x6d,
	0xcb, 0x5e, 0xbd, 0xfb, 0x77, 0xfc, 0x2b, 0x68, 0xcf, 0xe6, 0x6c, 0xea, 0x53, 0x26, 0x16, 0x19,
	0x2a, 0xc6, 0xed, 0xc1, 0x61, 0x91, 0xf6, 0x64, 0x34, 0x39, 0xd5, 0x36, 0x0f, 0x66, 0x73, 0x66,
	0xd6, 0xee, 0x11, 0x34, 0xd4, 0xf7, 0xbf, 0x0f, 0xed, 0x93, 0xd1, 0x64, 0x7a, 0x3a, 0x9c, 0x5c,
	0x5c, 0x7a, 0xaf, 0x0f, 0x6a, 0xee, 0xef, 0x16, 0x80, 0xa1, 0x22, 0xcb, 0x7b, 0x0a, 0x1d, 0x91,
	0x0a, 0x1a, 0x7d, 0x8f, 0x9c, 0xd3, 0x39, 0x72, 0xc5, 0xbb, 0xe1, 0x55, 0x41, 0xf2, 0x08, 0x76,
	0xb9, 0xa0, 0x99, 0xb8, 0x08, 0x63, 0x7d, 0x6d, 0x1a, 0x5e, 0x01, 0x48, 0x41, 0x31, 0x09, 0x94,
	0xad, 0xae, 0x6c, 0xf9, 0x96, 0x7c, 0x00, 0x90, 0x2c, 0xe2, 0x2b, 0xa3, 0x76, 0x43, 0xa9, 0x5d,
	0x42, 0xc8, 0x21, 0x6c, 0x63, 0x96, 0xa5, 0x99, 0xbd, 0xad, 0xca, 0xd6, 0x1b, 0xf7, 0x2f, 0x0b,
	0x60, 0x84, 0x22, 0x57, 0xf4, 0x79, 0x45, 0xd1, 0x87, 0x45, 0xe9, 0x85, 0xcf, 0x7f, 0xd0, 0xf3,
	0x33, 0xd8, 0x57, 0xcc, 0xa7, 0x22, 0x8c, 0x91, 0x0b, 0x1a, 0x33, 0x73, 0xe7, 0xbb, 0xb7, 0x05,
	0x29, 0x94, 0x7c, 0x0c, 0x1d, 0x4c, 0x82, 0x92, 0x5b, 0x43, 0xb9, 0xed, 0x99, 0xda, 0x14, 0x76,
	0xb7, 0xcc, 0xbf, 0x59, 0xd0, 0x52, 0xfc, 0xa4, 0xc8, 0x5f, 0x54, 0x2a, 0x38, 0x5a, 0xa9, 0x80,
	0x45, 0xcb, 0x32, 0xff, 0x17, 0xd0, 0x32, 0xcd, 0xe6, 0xf6, 0x96, 0xba, 0xa0, 0x9b, 0xbb, 0x7d,
	0xeb, 0x55, 0xa8, 0x58, 0x2f, 0xab, 0x78, 0x27, 0xb5, 0x3f, 0xb7, 0x00, 0x8a, 0x3c, 0xb2, 0xb7,
	0x45, 0x8d, 0x96, 0x6a, 0x51, 0x01, 0x90, 0x23, 0x68, 0x32, 0xc4, 0x6c, 0x4a, 0xb9, 0x92, 0xb2,
	0xe3, 0xed, 0xc8, 0xed, 0x90, 0x93, 0x87, 0xd0, 0x8a, 0x52, 0x9f, 0x46, 0xd2, 0x62, 0xae, 0x91,
	0xda, 0x0f, 0xb9, 0x94, 0x38, 0x4c, 0x04, 0x66, 0xd7, 0xd4, 0xc7, 0x69, 0x98, 0x04, 0xf8, 0xab,
	0x69, 0x7d, 0xf7, 0x16, 0x1e, 0x4b, 0x94, 0x7c, 0x02, 0x5d, 0x1a, 0x04, 0x19, 0x72, 0x3e, 0xbd,
	0xa6, 0x71, 0x18, 0x2d, 0xd5, 0x77, 0xd0, 0xf1, 0x3a, 0x06, 0x7d, 0xa3, 0x40, 0xf2, 0xd2, 0x70,
	0x08, 0x99, 0xbd, 0xa3, 0x3e, 0x7f, 0xbb, 0x67, 0x5e, 0x8e, 0xf1, 0x64, 0xa8, 0x3d, 0xaf, 0x32,
	0xca, 0x18, 0x66, 0x9a, 0xdd, 0x98, 0x91, 0xe3, 0x9c, 0x5d, 0xc8, 0xec, 0xe6, 0xbf, 0xc4, 0x68,
	0xde, 0x63, 0x46, 0x3e, 0x85, 0x9d, 0x05, 0x0b, 0xa8, 0x40, 0xbb, 0xa5, 0x42, 0xba, 0x52, 0x77,
	0x29, 0xf9, 0xa5, 0x42, 0x3d, 0x63, 0x1d, 0xfc, 0x5d, 0x87, 0xe6, 0x89, 0xea, 0x48, 0x40, 0xbe,
	0x85, 0xbd, 0xf2, 0x48, 0x24, 0x8f, 0x8b, 0x5e, 0x6d, 0x18, 0x95, 0xce, 0x7e, 0x61, 0xd6, 0xcf,
	0x55, 0x8d, 0xbc, 0x81, 0x83, 0xd5, 0xf1, 0x48, 0x56, 0xdd, 0x9c, 0x0f, 0x0b, 0x60, 0xe3, 0x2c,
	0x75, 0x6b, 0x64, 0xa2, 0xc7, 0xec, 0xda, 0x03, 0xb0, 0x9e, 0xec, 0x69, 0x35, 0xd9, 0xe6, 0x27,
	0xc3, 0xad, 0x91, 0x31, 0xb4, 0x4b, 0x07, 0x91, 0x47, 0x45, 0xd8, 0xfa, 0x5c, 0x76, 0x9c, 0x3b,
	0xac, 0x3a, 0xd5, 0x2b, 0xd8, 0x56, 0x43, 0x87, 0xbc, 0xb7, 0x79, 0x20, 0x3a, 0x87, 0x6b, 0xb8,
	0x0a, 0x7c, 0x66, 0x91, 0x63, 0xa8, 0x8f, 0x50, 0x90, 0xc3, 0x4d, 0xf7, 0xde, 0x21, 0xeb, 0x77,
	0xc9, 0xad, 0xbd, 0xb0, 0xc8, 0x5b, 0xe8, 0x8e, 0xe4, 0x0f, 0x88, 0xdb, 0x87, 0xb8, 0xcc, 0x7e,
	0xfd, 0x51, 0x2f, 0xb3, 0x5f, 0x7d, 0xbd, 0xdd, 0xda, 0x6c, 0x47, 0xfd, 0xc6, 0x38, 0xfe, 0x27,
	0x00, 0x00, 0xff, 0xff, 0xb0, 0x19, 0xd0, 0xc8, 0x26, 0x09, 0x00, 0x00,
}
