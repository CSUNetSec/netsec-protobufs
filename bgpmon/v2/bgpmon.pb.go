// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/CSUNetSec/netsec-protobufs/bgpmon/v2/bgpmon.proto

/*
Package bgpmonv2 is a generated protocol buffer package.

It is generated from these files:
	github.com/CSUNetSec/netsec-protobufs/bgpmon/v2/bgpmon.proto

It has these top-level messages:
	Empty
	RunModuleRequest
	RunModuleReply
	CloseModuleRequest
	ModuleInfo
	ListAvailableModulesReply
	OpenModuleInfo
	ListOpenModulesReply
	SessionType
	SessionInfoRequest
	SessionInfoReply
	ListAvailableSessionsReply
	CloseSessionRequest
	ListOpenSessionsReply
	OpenSessionRequest
	OpenSessionReply
	WriteRequest
	WriteReply
	GetRequest
	Filter
	GetReply
	BGPCapture
	Entity
*/
package bgpmonv2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "github.com/CSUNetSec/netsec-protobufs/common"
import bgp "github.com/CSUNetSec/netsec-protobufs/protocol/bgp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type WriteRequest_Type int32

const (
	WriteRequest_BGP_CAPTURE WriteRequest_Type = 0
	WriteRequest_ENTITY      WriteRequest_Type = 1
)

var WriteRequest_Type_name = map[int32]string{
	0: "BGP_CAPTURE",
	1: "ENTITY",
}
var WriteRequest_Type_value = map[string]int32{
	"BGP_CAPTURE": 0,
	"ENTITY":      1,
}

func (x WriteRequest_Type) String() string {
	return proto.EnumName(WriteRequest_Type_name, int32(x))
}
func (WriteRequest_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 0} }

type GetRequest_Type int32

const (
	GetRequest_CAPTURE GetRequest_Type = 0
	GetRequest_PREFIX  GetRequest_Type = 1
	GetRequest_ASPATH  GetRequest_Type = 2
	GetRequest_ENTITY  GetRequest_Type = 3
)

var GetRequest_Type_name = map[int32]string{
	0: "CAPTURE",
	1: "PREFIX",
	2: "ASPATH",
	3: "ENTITY",
}
var GetRequest_Type_value = map[string]int32{
	"CAPTURE": 0,
	"PREFIX":  1,
	"ASPATH":  2,
	"ENTITY":  3,
}

func (x GetRequest_Type) String() string {
	return proto.EnumName(GetRequest_Type_name, int32(x))
}
func (GetRequest_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{18, 0} }

// maximal field value = 4
type Filter_FilterType int32

const (
	Filter_ORIGIN_AS      Filter_FilterType = 0
	Filter_PREFIXEXACT    Filter_FilterType = 1
	Filter_PREFIXINCLUDED Filter_FilterType = 2
)

var Filter_FilterType_name = map[int32]string{
	0: "ORIGIN_AS",
	1: "PREFIXEXACT",
	2: "PREFIXINCLUDED",
}
var Filter_FilterType_value = map[string]int32{
	"ORIGIN_AS":      0,
	"PREFIXEXACT":    1,
	"PREFIXINCLUDED": 2,
}

func (x Filter_FilterType) String() string {
	return proto.EnumName(Filter_FilterType_name, int32(x))
}
func (Filter_FilterType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{19, 0} }

// Empty messages are used as return types for functions that don't need to return any data.
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// RunModuleRequest messages contain the type of the module that is requested to
// run , the ID and the arguments it should be invoked with.
type RunModuleRequest struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Id   string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Args string `protobuf:"bytes,3,opt,name=args" json:"args,omitempty"`
}

func (m *RunModuleRequest) Reset()                    { *m = RunModuleRequest{} }
func (m *RunModuleRequest) String() string            { return proto.CompactTextString(m) }
func (*RunModuleRequest) ProtoMessage()               {}
func (*RunModuleRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *RunModuleRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *RunModuleRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RunModuleRequest) GetArgs() string {
	if m != nil {
		return m.Args
	}
	return ""
}

// RunModuleReply messages contain the ID of the module that was just set to run.
type RunModuleReply struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *RunModuleReply) Reset()                    { *m = RunModuleReply{} }
func (m *RunModuleReply) String() string            { return proto.CompactTextString(m) }
func (*RunModuleReply) ProtoMessage()               {}
func (*RunModuleReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RunModuleReply) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// CloseModuleRequest messages contain the ID of the module that is requested to be closed.
type CloseModuleRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *CloseModuleRequest) Reset()                    { *m = CloseModuleRequest{} }
func (m *CloseModuleRequest) String() string            { return proto.CompactTextString(m) }
func (*CloseModuleRequest) ProtoMessage()               {}
func (*CloseModuleRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CloseModuleRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// ModuleInfo messages contain the type, description and option strings for a module.
type ModuleInfo struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Desc string `protobuf:"bytes,2,opt,name=desc" json:"desc,omitempty"`
	Opts string `protobuf:"bytes,3,opt,name=opts" json:"opts,omitempty"`
}

func (m *ModuleInfo) Reset()                    { *m = ModuleInfo{} }
func (m *ModuleInfo) String() string            { return proto.CompactTextString(m) }
func (*ModuleInfo) ProtoMessage()               {}
func (*ModuleInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ModuleInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ModuleInfo) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *ModuleInfo) GetOpts() string {
	if m != nil {
		return m.Opts
	}
	return ""
}

// ListAvailableModulesReply messages contain an array of ModuleInfo message
// for available modules.
type ListAvailableModulesReply struct {
	AvailableModules []*ModuleInfo `protobuf:"bytes,1,rep,name=available_modules,json=availableModules" json:"available_modules,omitempty"`
}

func (m *ListAvailableModulesReply) Reset()                    { *m = ListAvailableModulesReply{} }
func (m *ListAvailableModulesReply) String() string            { return proto.CompactTextString(m) }
func (*ListAvailableModulesReply) ProtoMessage()               {}
func (*ListAvailableModulesReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ListAvailableModulesReply) GetAvailableModules() []*ModuleInfo {
	if m != nil {
		return m.AvailableModules
	}
	return nil
}

// OpenModuleInfo messages contain the type, ID and status of currently open modules.
type OpenModuleInfo struct {
	Type   string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Id     string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Status string `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *OpenModuleInfo) Reset()                    { *m = OpenModuleInfo{} }
func (m *OpenModuleInfo) String() string            { return proto.CompactTextString(m) }
func (*OpenModuleInfo) ProtoMessage()               {}
func (*OpenModuleInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *OpenModuleInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *OpenModuleInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *OpenModuleInfo) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// ListOpenModulesReply messages contain an array of OpenModuleInfo
// messages for the currently open modules.
type ListOpenModulesReply struct {
	OpenModules []*OpenModuleInfo `protobuf:"bytes,1,rep,name=open_modules,json=openModules" json:"open_modules,omitempty"`
}

func (m *ListOpenModulesReply) Reset()                    { *m = ListOpenModulesReply{} }
func (m *ListOpenModulesReply) String() string            { return proto.CompactTextString(m) }
func (*ListOpenModulesReply) ProtoMessage()               {}
func (*ListOpenModulesReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ListOpenModulesReply) GetOpenModules() []*OpenModuleInfo {
	if m != nil {
		return m.OpenModules
	}
	return nil
}

// SessionType message contain the name, type and description of
// a session.
type SessionType struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Desc string `protobuf:"bytes,3,opt,name=desc" json:"desc,omitempty"`
}

func (m *SessionType) Reset()                    { *m = SessionType{} }
func (m *SessionType) String() string            { return proto.CompactTextString(m) }
func (*SessionType) ProtoMessage()               {}
func (*SessionType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SessionType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SessionType) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SessionType) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

// SessionInfoRequest messages contain the ID of the session on which
// more info is requested on.
type SessionInfoRequest struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *SessionInfoRequest) Reset()                    { *m = SessionInfoRequest{} }
func (m *SessionInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionInfoRequest) ProtoMessage()               {}
func (*SessionInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *SessionInfoRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

// SessionInfoReply messages contain the type and the configured number of
// workers for that session ID.
type SessionInfoReply struct {
	Type      *SessionType `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	SessionId string       `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	Workers   uint32       `protobuf:"varint,3,opt,name=workers" json:"workers,omitempty"`
}

func (m *SessionInfoReply) Reset()                    { *m = SessionInfoReply{} }
func (m *SessionInfoReply) String() string            { return proto.CompactTextString(m) }
func (*SessionInfoReply) ProtoMessage()               {}
func (*SessionInfoReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SessionInfoReply) GetType() *SessionType {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *SessionInfoReply) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *SessionInfoReply) GetWorkers() uint32 {
	if m != nil {
		return m.Workers
	}
	return 0
}

// ListAvailableSessionsReply messages return an array of the available
// session type names.
type ListAvailableSessionsReply struct {
	AvailableSessions []*SessionType `protobuf:"bytes,1,rep,name=available_sessions,json=availableSessions" json:"available_sessions,omitempty"`
}

func (m *ListAvailableSessionsReply) Reset()                    { *m = ListAvailableSessionsReply{} }
func (m *ListAvailableSessionsReply) String() string            { return proto.CompactTextString(m) }
func (*ListAvailableSessionsReply) ProtoMessage()               {}
func (*ListAvailableSessionsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ListAvailableSessionsReply) GetAvailableSessions() []*SessionType {
	if m != nil {
		return m.AvailableSessions
	}
	return nil
}

// CloseSessionRequest messages request the closing of
// session identified by ID.
type CloseSessionRequest struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *CloseSessionRequest) Reset()                    { *m = CloseSessionRequest{} }
func (m *CloseSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*CloseSessionRequest) ProtoMessage()               {}
func (*CloseSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *CloseSessionRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

type ListOpenSessionsReply struct {
	SessionId []string `protobuf:"bytes,1,rep,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *ListOpenSessionsReply) Reset()                    { *m = ListOpenSessionsReply{} }
func (m *ListOpenSessionsReply) String() string            { return proto.CompactTextString(m) }
func (*ListOpenSessionsReply) ProtoMessage()               {}
func (*ListOpenSessionsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ListOpenSessionsReply) GetSessionId() []string {
	if m != nil {
		return m.SessionId
	}
	return nil
}

// OpenSessionRequest messages request the opening of a session
// of a type named session_name, with an ID of session_id and the
// specified amount of worker threads.
type OpenSessionRequest struct {
	SessionName string `protobuf:"bytes,1,opt,name=session_name,json=sessionName" json:"session_name,omitempty"`
	SessionId   string `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	Workers     uint32 `protobuf:"varint,3,opt,name=workers" json:"workers,omitempty"`
}

func (m *OpenSessionRequest) Reset()                    { *m = OpenSessionRequest{} }
func (m *OpenSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenSessionRequest) ProtoMessage()               {}
func (*OpenSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *OpenSessionRequest) GetSessionName() string {
	if m != nil {
		return m.SessionName
	}
	return ""
}

func (m *OpenSessionRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *OpenSessionRequest) GetWorkers() uint32 {
	if m != nil {
		return m.Workers
	}
	return 0
}

// OpenSessionReply message return the ID of the session that was just
// opened.
type OpenSessionReply struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *OpenSessionReply) Reset()                    { *m = OpenSessionReply{} }
func (m *OpenSessionReply) String() string            { return proto.CompactTextString(m) }
func (*OpenSessionReply) ProtoMessage()               {}
func (*OpenSessionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *OpenSessionReply) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

// WriteRequest messages contain the type of the submessage that
// is to be written as well as the session ID that this should be
// performed on.
type WriteRequest struct {
	Type       WriteRequest_Type `protobuf:"varint,1,opt,name=type,enum=bgpmonv2.WriteRequest_Type" json:"type,omitempty"`
	SessionId  string            `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	BgpCapture *BGPCapture       `protobuf:"bytes,3,opt,name=bgp_capture,json=bgpCapture" json:"bgp_capture,omitempty"`
	Entity     *Entity           `protobuf:"bytes,4,opt,name=entity" json:"entity,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *WriteRequest) GetType() WriteRequest_Type {
	if m != nil {
		return m.Type
	}
	return WriteRequest_BGP_CAPTURE
}

func (m *WriteRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *WriteRequest) GetBgpCapture() *BGPCapture {
	if m != nil {
		return m.BgpCapture
	}
	return nil
}

func (m *WriteRequest) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

// WriteReply messages return the total number of messages written,
// the time range the request took , the number of workers used for the
// request as well as possible errors.
type WriteReply struct {
	TotalMessages uint64 `protobuf:"varint,1,opt,name=totalMessages" json:"totalMessages,omitempty"`
	StartTime     uint64 `protobuf:"varint,2,opt,name=startTime" json:"startTime,omitempty"`
	EndTime       uint64 `protobuf:"varint,3,opt,name=endTime" json:"endTime,omitempty"`
	NumWorkers    uint32 `protobuf:"varint,4,opt,name=numWorkers" json:"numWorkers,omitempty"`
	Error         string `protobuf:"bytes,5,opt,name=error" json:"error,omitempty"`
}

func (m *WriteReply) Reset()                    { *m = WriteReply{} }
func (m *WriteReply) String() string            { return proto.CompactTextString(m) }
func (*WriteReply) ProtoMessage()               {}
func (*WriteReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *WriteReply) GetTotalMessages() uint64 {
	if m != nil {
		return m.TotalMessages
	}
	return 0
}

func (m *WriteReply) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *WriteReply) GetEndTime() uint64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *WriteReply) GetNumWorkers() uint32 {
	if m != nil {
		return m.NumWorkers
	}
	return 0
}

func (m *WriteReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// GetRequest messages contain the type of the
// messages that the user wishes to have returned,
// the session ID on which the request should be performed,
// the filters associated and the collector name and relevant
// time range for the query.
type GetRequest struct {
	Type           GetRequest_Type `protobuf:"varint,1,opt,name=type,enum=bgpmonv2.GetRequest_Type" json:"type,omitempty"`
	SessionId      string          `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	Filters        []*Filter       `protobuf:"bytes,3,rep,name=filters" json:"filters,omitempty"`
	CollectorName  string          `protobuf:"bytes,4,opt,name=collector_name,json=collectorName" json:"collector_name,omitempty"`
	StartTimestamp uint64          `protobuf:"varint,5,opt,name=start_timestamp,json=startTimestamp" json:"start_timestamp,omitempty"`
	EndTimestamp   uint64          `protobuf:"varint,6,opt,name=end_timestamp,json=endTimestamp" json:"end_timestamp,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *GetRequest) GetType() GetRequest_Type {
	if m != nil {
		return m.Type
	}
	return GetRequest_CAPTURE
}

func (m *GetRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *GetRequest) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *GetRequest) GetCollectorName() string {
	if m != nil {
		return m.CollectorName
	}
	return ""
}

func (m *GetRequest) GetStartTimestamp() uint64 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

func (m *GetRequest) GetEndTimestamp() uint64 {
	if m != nil {
		return m.EndTimestamp
	}
	return 0
}

// Filter messages contain the type of filter that is to be run
// as well as field values that will be used to filter messages passed through
// the filter.
type Filter struct {
	Type             Filter_FilterType `protobuf:"varint,1,opt,name=type,enum=bgpmonv2.Filter_FilterType" json:"type,omitempty"`
	Origin_AS        uint32            `protobuf:"varint,2,opt,name=origin_AS,json=originAS" json:"origin_AS,omitempty"`
	AdvertisedPrefix string            `protobuf:"bytes,3,opt,name=advertised_prefix,json=advertisedPrefix" json:"advertised_prefix,omitempty"`
	WithdrawnPrefix  string            `protobuf:"bytes,4,opt,name=withdrawn_prefix,json=withdrawnPrefix" json:"withdrawn_prefix,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Filter) GetType() Filter_FilterType {
	if m != nil {
		return m.Type
	}
	return Filter_ORIGIN_AS
}

func (m *Filter) GetOrigin_AS() uint32 {
	if m != nil {
		return m.Origin_AS
	}
	return 0
}

func (m *Filter) GetAdvertisedPrefix() string {
	if m != nil {
		return m.AdvertisedPrefix
	}
	return ""
}

func (m *Filter) GetWithdrawnPrefix() string {
	if m != nil {
		return m.WithdrawnPrefix
	}
	return ""
}

// GetReply carries chunks of a PBStream byte array.
// If it is incomplete then the client should read all
// the following messages until the incomplete flag is not set
// and then try to unmarshal the message. Also the Type once an
// incomplete stream starts has to remain the same accros all subsequent
// messages
type GetReply struct {
	// maximal field value = 4
	Type       GetRequest_Type `protobuf:"varint,1,opt,name=type,enum=bgpmonv2.GetRequest_Type" json:"type,omitempty"`
	Error      string          `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	Incomplete bool            `protobuf:"varint,3,opt,name=incomplete" json:"incomplete,omitempty"`
	Chunk      [][]byte        `protobuf:"bytes,4,rep,name=chunk,proto3" json:"chunk,omitempty"`
}

func (m *GetReply) Reset()                    { *m = GetReply{} }
func (m *GetReply) String() string            { return proto.CompactTextString(m) }
func (*GetReply) ProtoMessage()               {}
func (*GetReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *GetReply) GetType() GetRequest_Type {
	if m != nil {
		return m.Type
	}
	return GetRequest_CAPTURE
}

func (m *GetReply) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *GetReply) GetIncomplete() bool {
	if m != nil {
		return m.Incomplete
	}
	return false
}

func (m *GetReply) GetChunk() [][]byte {
	if m != nil {
		return m.Chunk
	}
	return nil
}

// BGPCaprure messages facilitate the represtation of a
// BGP Update from multuple sources (live/mrt etc) to bgpmon
// and other systems. the inner actual update is defined in protocol/bgp
type BGPCapture struct {
	Timestamp      uint32                   `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Peer_AS        uint32                   `protobuf:"varint,2,opt,name=peer_AS,json=peerAS" json:"peer_AS,omitempty"`
	Local_AS       uint32                   `protobuf:"varint,3,opt,name=local_AS,json=localAS" json:"local_AS,omitempty"`
	InterfaceIndex uint32                   `protobuf:"varint,4,opt,name=interface_index,json=interfaceIndex" json:"interface_index,omitempty"`
	AddressFamily  uint32                   `protobuf:"varint,5,opt,name=address_family,json=addressFamily" json:"address_family,omitempty"`
	Peer_IP        *common.IPAddressWrapper `protobuf:"bytes,6,opt,name=peer_IP,json=peerIP" json:"peer_IP,omitempty"`
	Local_IP       *common.IPAddressWrapper `protobuf:"bytes,7,opt,name=local_IP,json=localIP" json:"local_IP,omitempty"`
	Update         *bgp.BGPUpdate           `protobuf:"bytes,8,opt,name=update" json:"update,omitempty"`
}

func (m *BGPCapture) Reset()                    { *m = BGPCapture{} }
func (m *BGPCapture) String() string            { return proto.CompactTextString(m) }
func (*BGPCapture) ProtoMessage()               {}
func (*BGPCapture) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *BGPCapture) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *BGPCapture) GetPeer_AS() uint32 {
	if m != nil {
		return m.Peer_AS
	}
	return 0
}

func (m *BGPCapture) GetLocal_AS() uint32 {
	if m != nil {
		return m.Local_AS
	}
	return 0
}

func (m *BGPCapture) GetInterfaceIndex() uint32 {
	if m != nil {
		return m.InterfaceIndex
	}
	return 0
}

func (m *BGPCapture) GetAddressFamily() uint32 {
	if m != nil {
		return m.AddressFamily
	}
	return 0
}

func (m *BGPCapture) GetPeer_IP() *common.IPAddressWrapper {
	if m != nil {
		return m.Peer_IP
	}
	return nil
}

func (m *BGPCapture) GetLocal_IP() *common.IPAddressWrapper {
	if m != nil {
		return m.Local_IP
	}
	return nil
}

func (m *BGPCapture) GetUpdate() *bgp.BGPUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}

type Entity struct {
	// maximal field value = 4
	Name          string                  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Email         string                  `protobuf:"bytes,2,opt,name=email" json:"email,omitempty"`
	OwnedOrigins  []int32                 `protobuf:"varint,3,rep,packed,name=ownedOrigins" json:"ownedOrigins,omitempty"`
	OwnedPrefixes []*common.PrefixWrapper `protobuf:"bytes,4,rep,name=ownedPrefixes" json:"ownedPrefixes,omitempty"`
}

func (m *Entity) Reset()                    { *m = Entity{} }
func (m *Entity) String() string            { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()               {}
func (*Entity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *Entity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Entity) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *Entity) GetOwnedOrigins() []int32 {
	if m != nil {
		return m.OwnedOrigins
	}
	return nil
}

func (m *Entity) GetOwnedPrefixes() []*common.PrefixWrapper {
	if m != nil {
		return m.OwnedPrefixes
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "bgpmonv2.Empty")
	proto.RegisterType((*RunModuleRequest)(nil), "bgpmonv2.RunModuleRequest")
	proto.RegisterType((*RunModuleReply)(nil), "bgpmonv2.RunModuleReply")
	proto.RegisterType((*CloseModuleRequest)(nil), "bgpmonv2.CloseModuleRequest")
	proto.RegisterType((*ModuleInfo)(nil), "bgpmonv2.ModuleInfo")
	proto.RegisterType((*ListAvailableModulesReply)(nil), "bgpmonv2.ListAvailableModulesReply")
	proto.RegisterType((*OpenModuleInfo)(nil), "bgpmonv2.OpenModuleInfo")
	proto.RegisterType((*ListOpenModulesReply)(nil), "bgpmonv2.ListOpenModulesReply")
	proto.RegisterType((*SessionType)(nil), "bgpmonv2.SessionType")
	proto.RegisterType((*SessionInfoRequest)(nil), "bgpmonv2.SessionInfoRequest")
	proto.RegisterType((*SessionInfoReply)(nil), "bgpmonv2.SessionInfoReply")
	proto.RegisterType((*ListAvailableSessionsReply)(nil), "bgpmonv2.ListAvailableSessionsReply")
	proto.RegisterType((*CloseSessionRequest)(nil), "bgpmonv2.CloseSessionRequest")
	proto.RegisterType((*ListOpenSessionsReply)(nil), "bgpmonv2.ListOpenSessionsReply")
	proto.RegisterType((*OpenSessionRequest)(nil), "bgpmonv2.OpenSessionRequest")
	proto.RegisterType((*OpenSessionReply)(nil), "bgpmonv2.OpenSessionReply")
	proto.RegisterType((*WriteRequest)(nil), "bgpmonv2.WriteRequest")
	proto.RegisterType((*WriteReply)(nil), "bgpmonv2.WriteReply")
	proto.RegisterType((*GetRequest)(nil), "bgpmonv2.GetRequest")
	proto.RegisterType((*Filter)(nil), "bgpmonv2.Filter")
	proto.RegisterType((*GetReply)(nil), "bgpmonv2.GetReply")
	proto.RegisterType((*BGPCapture)(nil), "bgpmonv2.BGPCapture")
	proto.RegisterType((*Entity)(nil), "bgpmonv2.Entity")
	proto.RegisterEnum("bgpmonv2.WriteRequest_Type", WriteRequest_Type_name, WriteRequest_Type_value)
	proto.RegisterEnum("bgpmonv2.GetRequest_Type", GetRequest_Type_name, GetRequest_Type_value)
	proto.RegisterEnum("bgpmonv2.Filter_FilterType", Filter_FilterType_name, Filter_FilterType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Bgpmond service

type BgpmondClient interface {
	CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*Empty, error)
	ListOpenSessions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListOpenSessionsReply, error)
	ListAvailableSessions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListAvailableSessionsReply, error)
	OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...grpc.CallOption) (*OpenSessionReply, error)
	Write(ctx context.Context, opts ...grpc.CallOption) (Bgpmond_WriteClient, error)
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (Bgpmond_GetClient, error)
	GetSessionInfo(ctx context.Context, in *SessionInfoRequest, opts ...grpc.CallOption) (*SessionInfoReply, error)
	RunModule(ctx context.Context, in *RunModuleRequest, opts ...grpc.CallOption) (*RunModuleReply, error)
	CloseModule(ctx context.Context, in *CloseModuleRequest, opts ...grpc.CallOption) (*Empty, error)
	ListAvailableModules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListAvailableModulesReply, error)
	ListOpenModules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListOpenModulesReply, error)
}

type bgpmondClient struct {
	cc *grpc.ClientConn
}

func NewBgpmondClient(cc *grpc.ClientConn) BgpmondClient {
	return &bgpmondClient{cc}
}

func (c *bgpmondClient) CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/CloseSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) ListOpenSessions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListOpenSessionsReply, error) {
	out := new(ListOpenSessionsReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/ListOpenSessions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) ListAvailableSessions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListAvailableSessionsReply, error) {
	out := new(ListAvailableSessionsReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/ListAvailableSessions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...grpc.CallOption) (*OpenSessionReply, error) {
	out := new(OpenSessionReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/OpenSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) Write(ctx context.Context, opts ...grpc.CallOption) (Bgpmond_WriteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Bgpmond_serviceDesc.Streams[0], c.cc, "/bgpmonv2.Bgpmond/Write", opts...)
	if err != nil {
		return nil, err
	}
	x := &bgpmondWriteClient{stream}
	return x, nil
}

type Bgpmond_WriteClient interface {
	Send(*WriteRequest) error
	CloseAndRecv() (*WriteReply, error)
	grpc.ClientStream
}

type bgpmondWriteClient struct {
	grpc.ClientStream
}

func (x *bgpmondWriteClient) Send(m *WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *bgpmondWriteClient) CloseAndRecv() (*WriteReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bgpmondClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (Bgpmond_GetClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Bgpmond_serviceDesc.Streams[1], c.cc, "/bgpmonv2.Bgpmond/Get", opts...)
	if err != nil {
		return nil, err
	}
	x := &bgpmondGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Bgpmond_GetClient interface {
	Recv() (*GetReply, error)
	grpc.ClientStream
}

type bgpmondGetClient struct {
	grpc.ClientStream
}

func (x *bgpmondGetClient) Recv() (*GetReply, error) {
	m := new(GetReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bgpmondClient) GetSessionInfo(ctx context.Context, in *SessionInfoRequest, opts ...grpc.CallOption) (*SessionInfoReply, error) {
	out := new(SessionInfoReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/GetSessionInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) RunModule(ctx context.Context, in *RunModuleRequest, opts ...grpc.CallOption) (*RunModuleReply, error) {
	out := new(RunModuleReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/RunModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) CloseModule(ctx context.Context, in *CloseModuleRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/CloseModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) ListAvailableModules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListAvailableModulesReply, error) {
	out := new(ListAvailableModulesReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/ListAvailableModules", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bgpmondClient) ListOpenModules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListOpenModulesReply, error) {
	out := new(ListOpenModulesReply)
	err := grpc.Invoke(ctx, "/bgpmonv2.Bgpmond/ListOpenModules", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Bgpmond service

type BgpmondServer interface {
	CloseSession(context.Context, *CloseSessionRequest) (*Empty, error)
	ListOpenSessions(context.Context, *Empty) (*ListOpenSessionsReply, error)
	ListAvailableSessions(context.Context, *Empty) (*ListAvailableSessionsReply, error)
	OpenSession(context.Context, *OpenSessionRequest) (*OpenSessionReply, error)
	Write(Bgpmond_WriteServer) error
	Get(*GetRequest, Bgpmond_GetServer) error
	GetSessionInfo(context.Context, *SessionInfoRequest) (*SessionInfoReply, error)
	RunModule(context.Context, *RunModuleRequest) (*RunModuleReply, error)
	CloseModule(context.Context, *CloseModuleRequest) (*Empty, error)
	ListAvailableModules(context.Context, *Empty) (*ListAvailableModulesReply, error)
	ListOpenModules(context.Context, *Empty) (*ListOpenModulesReply, error)
}

func RegisterBgpmondServer(s *grpc.Server, srv BgpmondServer) {
	s.RegisterService(&_Bgpmond_serviceDesc, srv)
}

func _Bgpmond_CloseSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).CloseSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/CloseSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).CloseSession(ctx, req.(*CloseSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_ListOpenSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).ListOpenSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/ListOpenSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).ListOpenSessions(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_ListAvailableSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).ListAvailableSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/ListAvailableSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).ListAvailableSessions(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_OpenSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).OpenSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/OpenSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).OpenSession(ctx, req.(*OpenSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_Write_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BgpmondServer).Write(&bgpmondWriteServer{stream})
}

type Bgpmond_WriteServer interface {
	SendAndClose(*WriteReply) error
	Recv() (*WriteRequest, error)
	grpc.ServerStream
}

type bgpmondWriteServer struct {
	grpc.ServerStream
}

func (x *bgpmondWriteServer) SendAndClose(m *WriteReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *bgpmondWriteServer) Recv() (*WriteRequest, error) {
	m := new(WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Bgpmond_Get_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BgpmondServer).Get(m, &bgpmondGetServer{stream})
}

type Bgpmond_GetServer interface {
	Send(*GetReply) error
	grpc.ServerStream
}

type bgpmondGetServer struct {
	grpc.ServerStream
}

func (x *bgpmondGetServer) Send(m *GetReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Bgpmond_GetSessionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).GetSessionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/GetSessionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).GetSessionInfo(ctx, req.(*SessionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_RunModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunModuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).RunModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/RunModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).RunModule(ctx, req.(*RunModuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_CloseModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseModuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).CloseModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/CloseModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).CloseModule(ctx, req.(*CloseModuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_ListAvailableModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).ListAvailableModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/ListAvailableModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).ListAvailableModules(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bgpmond_ListOpenModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BgpmondServer).ListOpenModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bgpmonv2.Bgpmond/ListOpenModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BgpmondServer).ListOpenModules(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Bgpmond_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bgpmonv2.Bgpmond",
	HandlerType: (*BgpmondServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CloseSession",
			Handler:    _Bgpmond_CloseSession_Handler,
		},
		{
			MethodName: "ListOpenSessions",
			Handler:    _Bgpmond_ListOpenSessions_Handler,
		},
		{
			MethodName: "ListAvailableSessions",
			Handler:    _Bgpmond_ListAvailableSessions_Handler,
		},
		{
			MethodName: "OpenSession",
			Handler:    _Bgpmond_OpenSession_Handler,
		},
		{
			MethodName: "GetSessionInfo",
			Handler:    _Bgpmond_GetSessionInfo_Handler,
		},
		{
			MethodName: "RunModule",
			Handler:    _Bgpmond_RunModule_Handler,
		},
		{
			MethodName: "CloseModule",
			Handler:    _Bgpmond_CloseModule_Handler,
		},
		{
			MethodName: "ListAvailableModules",
			Handler:    _Bgpmond_ListAvailableModules_Handler,
		},
		{
			MethodName: "ListOpenModules",
			Handler:    _Bgpmond_ListOpenModules_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Write",
			Handler:       _Bgpmond_Write_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Get",
			Handler:       _Bgpmond_Get_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "github.com/CSUNetSec/netsec-protobufs/bgpmon/v2/bgpmon.proto",
}

func init() {
	proto.RegisterFile("github.com/CSUNetSec/netsec-protobufs/bgpmon/v2/bgpmon.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1362 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xdb, 0x72, 0xdb, 0x44,
	0x18, 0xb6, 0x6c, 0xc7, 0x4e, 0x7e, 0x1f, 0xa2, 0x2e, 0x69, 0x71, 0xdd, 0x03, 0x61, 0x5b, 0x20,
	0x85, 0x69, 0x42, 0x13, 0x0e, 0xd3, 0x29, 0xc3, 0xd4, 0x75, 0x9c, 0x54, 0x4c, 0x9a, 0x7a, 0x64,
	0x67, 0x5a, 0x6e, 0xf0, 0xc8, 0xd2, 0xc6, 0xd5, 0x54, 0x27, 0xa4, 0x75, 0xd2, 0x3c, 0x00, 0x17,
	0x5c, 0xf3, 0x02, 0x3c, 0x04, 0xd7, 0x3c, 0x0d, 0x0f, 0xc0, 0x23, 0x30, 0x7b, 0xd0, 0xd1, 0xce,
	0x34, 0xe5, 0xc2, 0xe3, 0xdd, 0xef, 0x3f, 0xe8, 0xdb, 0xff, 0xfb, 0x57, 0xbb, 0x82, 0x1f, 0x66,
	0x36, 0x7d, 0x33, 0x9f, 0x6e, 0x9b, 0xbe, 0xbb, 0xd3, 0x1f, 0x9d, 0x1c, 0x13, 0x3a, 0x22, 0xe6,
	0x8e, 0x47, 0x68, 0x44, 0xcc, 0x87, 0x41, 0xe8, 0x53, 0x7f, 0x3a, 0x3f, 0x8d, 0x76, 0xa6, 0xb3,
	0xc0, 0xf5, 0xbd, 0x9d, 0xb3, 0x5d, 0x39, 0xda, 0xe6, 0x26, 0xb4, 0x2a, 0x66, 0x67, 0xbb, 0xdd,
	0xc7, 0x57, 0xcb, 0x63, 0xfa, 0x2e, 0xcb, 0x23, 0xfe, 0x44, 0x92, 0xee, 0x15, 0x29, 0xf0, 0x91,
	0xe9, 0x3b, 0x8c, 0x01, 0xfb, 0x89, 0x68, 0x5c, 0x87, 0x95, 0x81, 0x1b, 0xd0, 0x0b, 0xfc, 0x13,
	0xa8, 0xfa, 0xdc, 0x7b, 0xe1, 0x5b, 0x73, 0x87, 0xe8, 0xe4, 0xd7, 0x39, 0x89, 0x28, 0x42, 0x50,
	0xa5, 0x17, 0x01, 0xe9, 0x28, 0x9b, 0xca, 0xd6, 0x9a, 0xce, 0xc7, 0xa8, 0x0d, 0x65, 0xdb, 0xea,
	0x94, 0x39, 0x52, 0xb6, 0x2d, 0xe6, 0x63, 0x84, 0xb3, 0xa8, 0x53, 0x11, 0x3e, 0x6c, 0x8c, 0x37,
	0xa1, 0x9d, 0xc9, 0x15, 0x38, 0x17, 0x32, 0x4a, 0x89, 0xa3, 0xf0, 0x7d, 0x40, 0x7d, 0xc7, 0x8f,
	0x48, 0xfe, 0x79, 0x45, 0xaf, 0xe7, 0x00, 0xc2, 0x41, 0xf3, 0x4e, 0xfd, 0xa5, 0x6c, 0x10, 0x54,
	0x2d, 0x12, 0x99, 0x92, 0x0f, 0x1f, 0x33, 0xcc, 0x0f, 0x68, 0xc2, 0x88, 0x8d, 0xf1, 0x2f, 0x70,
	0xf3, 0xc8, 0x8e, 0x68, 0xef, 0xcc, 0xb0, 0x1d, 0x63, 0xea, 0xc8, 0xe7, 0x46, 0x82, 0x5c, 0x0f,
	0xae, 0x19, 0xb1, 0x61, 0xe2, 0x0a, 0x4b, 0x47, 0xd9, 0xac, 0x6c, 0x35, 0x76, 0x37, 0xb6, 0x63,
	0x89, 0xb6, 0x53, 0x26, 0xba, 0x6a, 0x14, 0xf2, 0xe0, 0x23, 0x68, 0xbf, 0x0c, 0x88, 0xf7, 0x1e,
	0xb6, 0xc5, 0xda, 0xdd, 0x80, 0x5a, 0x44, 0x0d, 0x3a, 0x8f, 0xb9, 0xca, 0x19, 0x1e, 0xc1, 0x06,
	0x63, 0x9b, 0x66, 0x94, 0x44, 0x9f, 0x40, 0xd3, 0x0f, 0x88, 0x57, 0xe0, 0xd8, 0x49, 0x39, 0xe6,
	0x39, 0xe8, 0x0d, 0x3f, 0xcd, 0x80, 0x35, 0x68, 0x8c, 0x48, 0x14, 0xd9, 0xbe, 0x37, 0x96, 0x95,
	0xf3, 0x0c, 0x37, 0xe1, 0xc7, 0xc6, 0x09, 0xe7, 0xf2, 0x92, 0x0a, 0x57, 0xd2, 0x0a, 0xe3, 0x3d,
	0x40, 0x32, 0x15, 0x7f, 0x8c, 0x54, 0xef, 0x0e, 0x40, 0x24, 0xd0, 0x49, 0xa2, 0xe2, 0x9a, 0x44,
	0x34, 0x0b, 0x9f, 0x81, 0x9a, 0x0b, 0x62, 0x0b, 0x7a, 0x90, 0x29, 0x52, 0x63, 0xf7, 0x7a, 0xba,
	0x90, 0x0c, 0x53, 0xc9, 0x23, 0x9f, 0xbd, 0x5c, 0xc8, 0x8e, 0x3a, 0x50, 0x3f, 0xf7, 0xc3, 0xb7,
	0x24, 0x14, 0xb5, 0x6c, 0xe9, 0xf1, 0x14, 0x4f, 0xa1, 0x9b, 0x93, 0x5e, 0xa6, 0x96, 0x25, 0xdd,
	0x07, 0x94, 0x6a, 0x2f, 0xd3, 0xc5, 0x85, 0xbd, 0x84, 0x4f, 0xda, 0x2c, 0x71, 0x2a, 0xfc, 0x0d,
	0x7c, 0xc4, 0xdb, 0x59, 0x02, 0x57, 0xac, 0xc8, 0x77, 0x70, 0x3d, 0x96, 0x39, 0x4f, 0xaa, 0x18,
	0x57, 0xc9, 0xc7, 0x05, 0x80, 0x32, 0x31, 0xf1, 0xc3, 0x3e, 0x85, 0x66, 0x1c, 0x94, 0x11, 0xb6,
	0x21, 0xb1, 0x63, 0xa6, 0xef, 0xff, 0xae, 0xe1, 0x23, 0x50, 0x73, 0x4f, 0x5c, 0x46, 0xb2, 0xb0,
	0xb8, 0x7f, 0x14, 0x68, 0xbe, 0x0a, 0x6d, 0x9a, 0x6c, 0xee, 0x9d, 0x8c, 0xd6, 0xed, 0xdd, 0x5b,
	0x69, 0x6d, 0xb3, 0x5e, 0xdb, 0x57, 0x57, 0xfc, 0x5b, 0x68, 0x4c, 0x67, 0xc1, 0xc4, 0x34, 0x02,
	0x3a, 0x0f, 0x09, 0x67, 0x9c, 0xdb, 0xaf, 0xcf, 0x0e, 0x87, 0x7d, 0x61, 0xd3, 0x61, 0x3a, 0x0b,
	0xe4, 0x18, 0x6d, 0x41, 0x8d, 0x78, 0xd4, 0xa6, 0x17, 0x9d, 0x2a, 0x8f, 0x50, 0xd3, 0x88, 0x01,
	0xc7, 0x75, 0x69, 0xc7, 0xf7, 0xa0, 0xca, 0x77, 0xca, 0x3a, 0x34, 0x9e, 0x1d, 0x0e, 0x27, 0xfd,
	0xde, 0x70, 0x7c, 0xa2, 0x0f, 0xd4, 0x12, 0x02, 0xa8, 0x0d, 0x8e, 0xc7, 0xda, 0xf8, 0x67, 0x55,
	0xc1, 0x7f, 0x2a, 0x00, 0x72, 0x01, 0xac, 0x28, 0xf7, 0xa1, 0x45, 0x7d, 0x6a, 0x38, 0x2f, 0x48,
	0x14, 0x19, 0x33, 0xbe, 0x45, 0x95, 0xad, 0xaa, 0x9e, 0x07, 0xd1, 0x6d, 0x58, 0x8b, 0xa8, 0x11,
	0xd2, 0xb1, 0xed, 0x8a, 0xcd, 0x56, 0xd5, 0x53, 0x80, 0xc9, 0x40, 0x3c, 0x8b, 0xdb, 0x2a, 0xdc,
	0x16, 0x4f, 0xd1, 0x5d, 0x00, 0x6f, 0xee, 0xbe, 0x92, 0x1a, 0x55, 0xb9, 0x46, 0x19, 0x04, 0x6d,
	0xc0, 0x0a, 0x09, 0x43, 0x3f, 0xec, 0xac, 0xf0, 0x62, 0x89, 0x09, 0xfe, 0xab, 0x0c, 0x70, 0x48,
	0x68, 0xac, 0xc3, 0xc3, 0x9c, 0x0e, 0x37, 0xd3, 0xe5, 0xa7, 0x3e, 0x1f, 0xa0, 0xc2, 0x97, 0x50,
	0x3f, 0xb5, 0x1d, 0x2a, 0x7a, 0xa6, 0x92, 0xaf, 0xe7, 0x01, 0x37, 0xe8, 0xb1, 0x03, 0xfa, 0x0c,
	0xda, 0xa6, 0xef, 0x38, 0xc4, 0xa4, 0x7e, 0x28, 0x7a, 0xb4, 0xca, 0xd3, 0xb5, 0x12, 0x94, 0x77,
	0xe9, 0x17, 0xb0, 0xce, 0x8b, 0x31, 0xa1, 0xb6, 0x4b, 0x22, 0x6a, 0xb8, 0x01, 0x5f, 0x4f, 0x55,
	0x6f, 0x27, 0x35, 0xe2, 0x28, 0xba, 0x07, 0x2d, 0xe2, 0x59, 0x19, 0xb7, 0x1a, 0x77, 0x6b, 0xca,
	0x72, 0x71, 0x0c, 0x7f, 0x2f, 0x55, 0x6c, 0x40, 0x3d, 0xa7, 0xe0, 0x50, 0x1f, 0x1c, 0x68, 0xaf,
	0x55, 0x85, 0x8d, 0x7b, 0xa3, 0x61, 0x6f, 0xfc, 0x5c, 0x2d, 0x67, 0x94, 0xad, 0xe0, 0x7f, 0x15,
	0xa8, 0x89, 0x15, 0x5c, 0xde, 0xba, 0xc2, 0x2e, 0xff, 0x32, 0x45, 0xbb, 0x05, 0x6b, 0x7e, 0x68,
	0xcf, 0x6c, 0x6f, 0xd2, 0x1b, 0xf1, 0x9a, 0xb5, 0xf4, 0x55, 0x01, 0xf4, 0x46, 0xe8, 0x2b, 0xb8,
	0x66, 0x58, 0x67, 0x24, 0xa4, 0x76, 0x44, 0xac, 0x49, 0x10, 0x92, 0x53, 0xfb, 0x9d, 0x7c, 0xbd,
	0xaa, 0xa9, 0x61, 0xc8, 0x71, 0xf4, 0x00, 0xd4, 0x73, 0x9b, 0xbe, 0xb1, 0x42, 0xe3, 0xdc, 0x8b,
	0x7d, 0x45, 0xd5, 0xd6, 0x13, 0x5c, 0xb8, 0xe2, 0xa7, 0x00, 0x29, 0x11, 0xd4, 0x82, 0xb5, 0x97,
	0xba, 0x76, 0xa8, 0x1d, 0x4f, 0x7a, 0x23, 0xb5, 0xc4, 0x9a, 0x58, 0xac, 0x78, 0xf0, 0xba, 0xd7,
	0x1f, 0xab, 0x0a, 0x42, 0xd0, 0x16, 0x80, 0x76, 0xdc, 0x3f, 0x3a, 0xd9, 0x1f, 0xec, 0xab, 0x65,
	0xfc, 0x9b, 0x02, 0xab, 0xbc, 0x0b, 0x58, 0x2b, 0x7f, 0x60, 0x9f, 0x24, 0xbd, 0x57, 0xce, 0xf4,
	0x1e, 0xeb, 0x58, 0xdb, 0x33, 0x7d, 0x37, 0x70, 0x08, 0x15, 0xed, 0xbc, 0xaa, 0x67, 0x10, 0x16,
	0x65, 0xbe, 0x99, 0x7b, 0x6f, 0x3b, 0xd5, 0xcd, 0xca, 0x56, 0x53, 0x17, 0x13, 0xfc, 0x77, 0x19,
	0x20, 0xdd, 0xbe, 0x6c, 0xbb, 0xa4, 0x1a, 0x2b, 0xbc, 0x9a, 0x29, 0x80, 0x3e, 0x86, 0x7a, 0x40,
	0x48, 0x98, 0x56, 0xba, 0xc6, 0xa6, 0xbd, 0x11, 0xba, 0x09, 0xab, 0x8e, 0x6f, 0x1a, 0x0e, 0xb3,
	0xc8, 0xf7, 0x19, 0x9f, 0xf7, 0x46, 0xac, 0xc5, 0x6c, 0x8f, 0x92, 0xf0, 0xd4, 0x30, 0xc9, 0xc4,
	0xf6, 0x2c, 0xf2, 0x4e, 0xee, 0xa6, 0x76, 0x02, 0x6b, 0x0c, 0x65, 0x2d, 0x6b, 0x58, 0x56, 0x48,
	0xa2, 0x68, 0x72, 0x6a, 0xb8, 0xb6, 0x73, 0xc1, 0x5b, 0xb1, 0xa5, 0xb7, 0x24, 0x7a, 0xc0, 0x41,
	0xf4, 0x48, 0x72, 0xd0, 0x86, 0xbc, 0x07, 0xd9, 0x99, 0x2c, 0xef, 0x68, 0xda, 0xb0, 0x27, 0x3c,
	0x5f, 0x85, 0x46, 0x10, 0x90, 0x50, 0xb0, 0xd3, 0x86, 0x68, 0x2f, 0x66, 0xa7, 0x0d, 0x3b, 0xf5,
	0xf7, 0xc4, 0x08, 0xde, 0xda, 0x10, 0x7d, 0x0e, 0xb5, 0x79, 0x60, 0x19, 0x94, 0x74, 0x56, 0x79,
	0x48, 0x9b, 0xa9, 0xc2, 0xde, 0x74, 0x27, 0x1c, 0xd5, 0xa5, 0x15, 0xff, 0xa1, 0x40, 0x4d, 0xbc,
	0xcd, 0x96, 0x9e, 0xf3, 0x4c, 0x2b, 0xd7, 0xb0, 0x9d, 0x44, 0x2b, 0x36, 0x41, 0x18, 0x9a, 0xfe,
	0xb9, 0x47, 0xac, 0x97, 0xbc, 0x51, 0xc5, 0x7e, 0x5e, 0xd1, 0x73, 0x18, 0x7a, 0x02, 0x2d, 0x3e,
	0x17, 0x2d, 0x47, 0x22, 0xae, 0x1b, 0x3b, 0x29, 0x25, 0x75, 0x81, 0xc7, 0xbc, 0xf3, 0xbe, 0xbb,
	0xbf, 0xd7, 0xa0, 0xfe, 0x8c, 0x77, 0x91, 0x85, 0x9e, 0x42, 0x33, 0x7b, 0x62, 0xa2, 0x3b, 0x69,
	0x7f, 0x2d, 0x39, 0x49, 0xbb, 0xeb, 0x99, 0xb7, 0x34, 0xbf, 0xae, 0x96, 0xd0, 0x01, 0xa8, 0xc5,
	0xd3, 0x13, 0x15, 0xdd, 0xba, 0x9f, 0xa4, 0xc0, 0xd2, 0xa3, 0x16, 0x97, 0xd0, 0x50, 0x9c, 0xc2,
	0x0b, 0xf7, 0x83, 0xc5, 0x64, 0xf7, 0xf3, 0xc9, 0x96, 0xdf, 0x28, 0x70, 0x09, 0x69, 0xd0, 0xc8,
	0x3c, 0x08, 0xdd, 0xce, 0xdf, 0xcf, 0x0a, 0x2b, 0xeb, 0x5e, 0x62, 0x15, 0xa9, 0x1e, 0xc3, 0x0a,
	0x3f, 0x5d, 0xd0, 0x8d, 0xe5, 0xe7, 0x65, 0x77, 0x63, 0x01, 0xe7, 0x81, 0x5b, 0x0a, 0xda, 0x83,
	0xca, 0x21, 0xa1, 0x68, 0x63, 0xd9, 0xc6, 0xed, 0xa2, 0x02, 0xca, 0x83, 0xbe, 0x56, 0xd0, 0x11,
	0xb4, 0x0f, 0xd9, 0x07, 0x44, 0x72, 0x4f, 0xcb, 0xb2, 0x5f, 0xbc, 0xf3, 0x65, 0xd9, 0x17, 0x2f,
	0x77, 0xb8, 0x84, 0xfa, 0xb0, 0x96, 0x7c, 0x07, 0xa0, 0x8c, 0x6b, 0xf1, 0x43, 0xa3, 0xdb, 0x59,
	0x6a, 0x13, 0x49, 0x7e, 0x84, 0x46, 0xe6, 0x53, 0x21, 0xcb, 0x67, 0xf1, 0x0b, 0x62, 0x59, 0x9f,
	0x1c, 0x8b, 0xcb, 0x74, 0xf1, 0xea, 0xbf, 0x28, 0xef, 0xbd, 0x4b, 0xe4, 0xcd, 0x5e, 0xc1, 0x71,
	0x09, 0xed, 0xc3, 0x7a, 0xe1, 0x72, 0xbe, 0x98, 0xea, 0xee, 0x62, 0xdb, 0xe5, 0xb3, 0x4c, 0x6b,
	0xfc, 0xf3, 0x6b, 0xef, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x76, 0x51, 0xc9, 0x40, 0x41, 0x0e,
	0x00, 0x00,
}
